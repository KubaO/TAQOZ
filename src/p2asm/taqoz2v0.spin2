CON

XIN		= 12_000_000
xmode		= 3			' 2 for xtal, 3 for osc'
CPUHZ		= 120_000_000		' desired CPU clock frequency'
baud_rate       = 115200		' console baud rate - timing value calculated at startup'

CON

{
_XTALFREQ     = 20_000_000                                    ' crystal frequency
 _XDIV         = 4             '\                              '\ crystal divider                      to give 5.0MHz
 _XMUL         = 72            '| 180MHz                       '| crystal / div * mul                  to give 360MHz
 _XDIVP        = 2             '/                              '/ crystal / div * mul /divp            to give 180MHz
 _XOSC         = %10                                   'OSC    ' %00=OFF, %01=OSC, %10=15pF, %11=30pF
 _XSEL         = %11                                   'XI+PLL ' %00=rcfast(20+MHz), %01=rcslow(~20KHz), %10=XI(5ms), %11=XI+PLL(10ms)
 _XPPPP        = ((_XDIVP>>1) + 15) & $F                       ' 1->15, 2->0, 4->1, 6->2...30->14
 _CLOCKFREQ    = _XTALFREQ / _XDIV * _XMUL / _XDIVP            ' internal clock frequency
 _SETFREQ      = 1<<24 + (_XDIV-1)<<18 + (_XMUL-1)<<8 + _XPPPP<<4 + _XOSC<<2  ' %0000_000e_dddddd_mmmmmmmmmm_pppp_cc_00  ' setup  oscillator
 _ENAFREQ      = _SETFREQ + _XSEL                                             ' %0000_000e_dddddd_mmmmmmmmmm_pppp_cc_ss  ' enable oscillator
}

'		     XIDIV  XIMUL       VCODIV
' CLOCK MODE 	= %E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS
PLLEN		= %1_0000_0000_0000_0000_0000_0000
NOXI		= %0_0000_0000_0000_0000_0000_0000
PF0		= %0_0000_0000_0000_0000_0000_0100
PF15		= %0_0000_0000_0000_0000_0000_1000
PF30		= %0_0000_0000_0000_0000_0000_1100

_RCFAST		= %0_0000_0000_0000_0000_0000_0000
_RCSLOW		= %0_0000_0000_0000_0000_0000_0001
XINCLK		= %0_0000_0000_0000_0000_0000_0010	' use XIN
PLLCLK		= %0_0000_0000_0000_0000_0000_0011	' use PLL

' The PLL output frequency will be Freq(VCO) if %PPPP = 15, else Freq(VCO) / (%PPPP + 1) / 2.
XIDIV		= 1			' crystal/osc input divider'
VCODIV		= 1
CLKMUL		= CPUHZ/(XIN/XIDIV)
CLKCFG		= 1<<24+(XIDIV-1)<<18+(CLKMUL-1)<<8+((VCODIV-2)&$0F)<<4+PF15



baudval         = (cpuhz/baud_rate)<<16


' SERIAL COMS
rx_pin		= 63		'pin serial receiver
tx_pin		= 62		'pin serial transmitter
' SPI FLASH
spi_cs		= 61		'pin SPI memory select		(also sd_ck)
spi_ck		= 60		'pin SPI memory clock		(also sd_cs)
spi_di		= 59		'pin SPI memory data in		(also sd_di)
spi_do		= 58		'pin SPI memory data out	(also sd_do)
' SD CARD
sd_cs		= spi_ck
sd_ck		= spi_cs
sd_di		= spi_di
sd_do		= spi_do


' *** MEMORY MAP *** '

' DEBUG "REGISTERS" - set to high cog memory'
hr0		= $1EE
hr1		= $1EF
xreg		= $1ED


registers       = $0200           	'Variables used by kernel + general-purpose

_hubrom		= $0400			' start of TAQOZ code'

SDBUFS		= $10000		' allocate 4k for buffers
rxbuffers       = $1C000		' SERIAL RX buffer
  rxsize          = $4000
datram		= $12000		' start of data memory - user variables '

' ^^^^^^^^^^ '
' DICTIONARY '
ramdict         = $0F400                 ' dictionary can be moved elsewhere at runtime'

bmporg		= $30000		' start of bmp header, palette, and bitmap data '

flashpart	= $E0000
flashpage	= flashpart>>16
flashsig	= $FFFFC




'************* VGA & KEYBOARD ************* '

vgacog		= 7			' vga runs in this cog '

DAT	' STAGE 1 - BOOT TIME INITIALIZATION '

		orgh	0
		org
		jmp	#initsys

'**************** configuration block **************** '
''
		byte	"P2D2F   "		' 8 character ID'
_OPTIONS	byte	%0000_0011		' options    SD,FLASH
		byte	0,0,0

'	*** CLOCK ***	'
_XIN		long	XIN			' input freqency'
_CPUHZ		long	CPUHZ			' final clock '
_CLKCFG		long	CLKCFG		''$012C_B3FF $014CB3FC '

'	*** SERIAL/VGA/KEYBOARD *** '
_BAUD		long	baud_rate
_VGACFG		long	$03020100		' VGA RGBH pins
		long	4			' VSYNCH'
_VGAINIT	long	@vgainit		' VGA code '
_VGASET		long	round(fset)
_KBCFG		long	$0607			' PS/2 CLK,DAT'

'	*** RESET VECTORS *** '
_RESET		long	@RESET
_IDLE		long	@IDLE
_TERMINAL	long	@TERMINAL		' COG0 TASK'
_COG1		long	0			' COG1 TASK ( 0=none )
_COG2		long	0
_COG3		long	0
_COG4		long	0
_COG5		long	0
_COG6		long	0
_COG7		long	0

' This code is jumped to from location 0 and follows after the boot parameters list

initsys		hubset	#0				' SWITCH TO RCFAST'
		mov	hr1,_CLKCFG
		hubset	hr1
		waitx	##20_000_000/100		' wait ~10ms for crystal+PLL to stabilize
		or	hr1,#xmode			' use PLL bits'
		hubset	hr1
		drvh	#tx_pin
		tjz	_VGACFG,#.L1 '$+2			' ignore VGA if no pins assigned (all zeros)
		coginit #vgacog,_VGAINIT
.L1		tjz	_COG1,#$+2			' user specified startup code for cogs 1...7 '
		coginit	#1,_COG1
		tjz	_COG2,#$+2
		coginit	#2,_COG2
		tjz	_COG3,#$+2
		coginit	#3,_COG3
		tjz	_COG4,#$+2
		coginit	#4,_COG4
		tjz	_COG5,#$+2
		coginit	#5,_COG5
		tjz	_COG6,#$+2
		coginit	#6,_COG6
		tjz	_COG7,#$+2
		coginit	#7,_COG7
''
		coginit	#0,_RESET


' ****************** GLOBAL VARIABLES ******************'
'
' global variables located in first 1k of memory (10-bit literal)'
'

rxrd		word 0
rxwr		word 0
lastkey		word 0
athen		word 0

sdvars				' $00A4..$01AF'




		orgh	_hubrom			' move '

{
DBIP		jmp	#DBPRINTA

DBPRINTA
		mov	xreg,PTRA
		call	#DBPRINT
		mov	hr0,#":"
		call	#DBTX
		mov	xreg,fx
		jmp	#DBPRINTX

DBPRTSTK
		mov	hr0,#"="
		call	#DBTX
		mov	xreg,tos
		call	#DBPRINTX
		mov	xreg,tos+1
		call	#DBPRINTX
		mov	xreg,tos+2
		call	#DBPRINTX
		mov	xreg,tos+3
DBPRINTX	'mov	xreg,fx
		mov	hr0,#$20
		call	#DBTX
		jmp	#DBPN
DBPRINT		call	#DBCR
		mov	hr0,#"$"
		call	#DBTX
DBPN		mov	hr1,#8
.L0		mov	hr0,xreg
		shr	hr0,#28
		add	hr0,#$30
		cmp	hr0,#$3A wc
	if_nc	add	hr0,#7
		call	#DBTX
		rol	xreg,#4
		djnz	hr1,#.L0
		mov	hr0,#$20
		jmp	#DBTX

DBCR		mov	hr0,#$0D
		call	#DBTX
		mov	hr0,#$0A
DBTX		'wxpin	##((cpuhz/115200)<<16)+7,#tx_pin
		wypin   hr0,#tx_pin             '..send byte
		waitx	#0
.l0		testp   #tx_pin         wc      '..wait for buffer empty
	if_nc	jmp     #.l0
		ret

}

InitTaqoz
		rdlong	PTRA,#@_IDLE
		cogid   fx
                tjnz    fx,#@INITSTKS
' COG 0 CONSOLE '
		call	#InitSerial
		jmp	#@INITSTKS


'*******************************************************************************
'*                                                                             *
'*          TAQOZ - Tachyon Forth for the Parallax P2 CPU ROM                  *
'*                                                                             *
'*******************************************************************************


CON

	sys_clk         = CPUHZ
        nscnt           = 100000/(sys_clk/1000000)

' 180524 - implement 10-bit short literals and 9-bit task register addresses for compact fat32 variables'

	w               =       $F800           ' wordcode offset for 10-bit literals 0..1023
        _IF             =       $FC00           ' IF relative forward branch 0 to 127 words
        _UNTIL          =       $FC80           ' UNTIL relative reverse branch 0 to 127 words
	opunused	= 	$FD00		' ???? could use'
	rg		= 	$FE00          ' task/cog register 8-bit offset
''	fat		=	$FF00
        tasks           = 	registers+$D0   	' 2 longs/task * 8 cogs

        SKIPZ           =       _IF+01		' short-form for _IF+01'

	ex              =       1               ' EXITs (jump to hub wordcode instead of call)

        _FALSE          =       w+0		' quick constants '
        _0              =       w+0
        _1              =       w+1
        _2              =       w+2
        _3              =       w+3
        _4              =       w+4
        _5              =       w+5
        _6              =       w+6
        _7              =       w+7
        _8              =       w+8
        _9              =       w+9
        _13             =       w+13
        _16             =       w+16
        _32             =       w+32
        _BL             =       w+32


CON
' Offsets in LUT for stacks
	datstk          = $000
	brastk          = $020
	lpstk           = $030
	retstk          = $040
	lutfree		= $080
' The LUT is essentially free from $80 onwards

	lmbuf		= $180
	  lmsz		= $200-lmbuf

CON


	numpadsz        = 44            ' We really only need a large buffer for when long binary numbers with separators are used
	                                ' 26 digits for double number 18,446,744,073,709,551,615
	wordsz          = 44            ' any word including binary numbers up to n characters (1 count, 1 terminator)
	tasksz          = 8             ' 8 bytes/task RUN[2] FLAG[1]

	' fflags
	echo            = 1
	'linenums       = 2             ' prepend line number to each new line
	ipmode          = 4             ' interpret this number in IP format where a "." separates bytes


	prset           = $10           ' private headers set as default
	sign            = $20
	comp            = $40           ' force compilation of the current word - resets each time
	defining        = $80



	WW		= $FFFF

	cntm    	= $1F           ' mask for nfa count byte to mask off atrs'

	' Dictionary header attribute flags
	pubatr  	= 0		' normal public attribute
	priatr  	= 1		' private - header can be reclaimed
	preatr  	= 2		' preemptive - executes immediately
	cliatr  	= 3		' command line interactive but compiles in definition

	maxlen  	= 15

'' attach these to count bytes in dictionary i.e. byte 2+im,"IF"
	im      	= preatr<<6           'lexicon immediate bit
	pr      	= priatr<<6           'private (flagged for removal from the dictionary)
	cli		= cliatr<<6
		' defs for TAQOZ '
dat
		orgh

taqoz_version    	long    2_0
taqoz_time		long	190212_1700
taqoz_name		byte	"CHIP"	' use exactly 4 characters = 1 long'
{

190112
Changed arrangement of hubexec code and put it back after cog code so threaded simply builds up to $FC00 max.
This speeds up doNEXT as well.
Data pointer set to $1.2000



}
		' version header '


'************************************* HUB REGISTERS **************************************

                org  0
' register offsets within "registers". Access as    REG,delim   ...  REG,base ... etc
'
' Minimum registers required for a new task - other registers after the ' ---- are not needed other than by the console
temp            res 12          ' general purpose
double          res 4           ' hold high word of double
' @16
uemit           res 2           ' emit vector 0 = default
ukey            res 2           ' key vector
keypoll         res 2           ' poll user routines - low priority background task
base            res 2           ' current number base + backup location during overrides
baudcnt         res 4           ' SERIN SEROUT baud cnt value where baud = clkfreq/baudcnt each cog can have it's own
uswitch         res 4           ' target parameter used in CASE structures
' @32
fflags          res 2           ' echo,linenums,ipmode,leadspaces,prset,striplf,sign,comp,defining

keycol          res 1           ' maintains column position of key input

wordcnt         res 1           ' length of current word (which is still null terminated)
wordbuf         res wordsz              ' words from the input stream are assembled here
' numpad may continue to build backwards into wordbuf for special cases such as long binary numnbers
numpad          res numpadsz    ' Number print format routines assemble digit characters here builds from end - 18,446,744,073,709,551,615
padwr           res 1           ' write index (builds characters down from lsb to msb in MODULO style)


'leader         res 1

pflg            res 1
pbase           res 1
pfmt            res 4



delim           res 2           ' the delimiter used in text input and a save location
dcnt		res 1
prefix          res 1           ' NUMBER input prefix
uprompt         res 2           ' pointer to code to execute when Forth prompts for a new line
uaccept         res 2           ' pointer to code to execute when Forth accepts a line to interpret (0=ok)
unum            res 2           ' User number processing routine - executed if number failed and UNUM <> 0
ufind           res 2           ' runs extended dictionary search if set after failing precompiled dictionary search

keychar         res 4           ' override for key character

suffix          res 1           ' NUMBER input suffix
                res 3



'
' ------ console only registers not required for other tasks  --- can be accessed as globals
'


' these 4 variables are cleared as an array of 10 bytes
anumber         res 4           ' Assembled number from input
hnumber		res 4		' high word of double number'
bnumber         res 4		' part of IP notation number'
digits          res 1           ' number of digits in current number that has just been processed
dpl             res 1           ' Position of the decimal point if encountered (else zero)

'createvec      res 2           ' If set will execute user create routines rather than the kernel's (CREATE revectored)

dmm             res 6           ' dump "fetch' vectors to allow dump to access special devices
dmp             res 2           ' DUMP vector

''''''''''''''''''''''' fixed ''''''''''''''''''''''''''''


oldnames        res 4           ' backup of names used at start of TAQOZ load
names           res 4           ' start of dictionary (builds down)
fromhere        res 4           ' Used by TAQOZ word to backup current here to determine code size at end of load
here            res 4           ' pointer to compilation area (overwrites VM image)
codes           res 4           ' current code compilation pointer (updates "here" or is reset by it)
autovec         res 4           ' user autostart address if non-zero - called from within terminal
''
cold            res 2           ' pattern to detect if this is a cold or warm start ($A55A )
errors          res 2
linenum         res 2
atrs		res 1
prevch          res 1           ' used to detect LF only sequences vs CRLF to perform auto CR

spincnt         res 2           ' Used by spinner to rotate busy symbol
                res 2           ' word count

endreg          res 0
	' defs for TAQOZ variables '
'*********************************************************************************************************
'************************************** TACHYON COG KERNEL ***********************************************
'*********************************************************************************************************

                org 0
RESET
           	call    #@InitTaqoz
                jmp     #doNEXT

'********************************** data *************************************


' Registers used by PASM modules to hold parameters such as I/O masks and bit counts etc
' COG 2
sck
REG0            long 0
mosi
REG1            long 0
miso
REG2            long 0
ss
REG3            long 0
REG4            long 0
                long 0
                long 0

' $00E0
' COG 9 = TASK REGISTER POINTER
regptr          long registers                          ' used by REG

ACC             long    0
fx              long    0
R0              long    0
R1              long    0
P
R2              long    0
R3              long    0
R4
deltaR          long    0


' COG 17 STACK POINTERS
datptr          long    0                               ' data stack pointer to LUT
braptr          long    0                               ' branch stack pointer to LUT
lpptr           long    0
retptr          long    0                               ' return stack pointer to LUT
' COG 21
lap1            long    0
lap2            long    0
depth           long    0
' #0024
pinreg          long    0
tepin           long    0
pinticks        long    sys_clk / 1000000               ' set default 1Mbaud

' #0027
clockpins       long 0                                  ' I/O mask for CLOCK instruction
clkdly          long 0

' #0029 rx isr variables
rxlong		long 0
rxz		long 0
rxwrP		long 0
rxwrC		long 0




' *** COG STACKS ***

' top of data stack registers
tos                     long    $DEADBEE1
tos1                    long    $DEADBEE2
tos2                    long    $DEADBEE3
tos3                    long    $DEADBEE4

' top of loop stack registers
index                   long    0
limit1                  long    0
index2                  long    0
limit2                  long    0

branchadr               long    0
seed                    long    1

'******************** MAIN KERNEL CODE *********************** '

' main Forth wordcode interpreter - PTRA = Instruction Pointer
' wordcode order: ASM,THREADED,HUBEXEC,IF,UNTIL,REG,LIT9
''
{
	w               =       $F800           ' wordcode offset for 10-bit literals
        _IF             =       $FC00           ' IF relative forward branch 0 to 127 words
        _UNTIL          =       $FC80           ' UNTIL relative reverse branch 0 to 127 words
	opunused	= 	$FD00
	rg		= 	$FE00          ' task/cog register 8-bit offset
	fat		=	$FF00
}

' constants used by doNEXT decode
'cogadr                  long    496
threaded		long	@THREADS-1	''(_hubexec-1)&$FFFF
'calls			long	$F800-1
coded			long	$F800-1
shorts                  long    $FC00-1
branches		long	$FD00-1
' registers		long	$FE00-1
{
081c0 030 000001f0 cogadr                  long    496
081c4 031 0000a453 threaded		long	(_hubexec-1)&$FFFF
081c8 032 0000f7ff calls			long	$F800-1
081cc 033 0000fbff shorts                  long    $FC00-1
081d0 034 0000fcff branches		long	$FD00-1

}
'
'
'***************************** MAIN WORDCODE EXECUTION LOOP ***************************
'
doCALL                  call    fx                      ' could call cog or hub code - use ret to return
doNEXT                 	rdword  fx,PTRA++               ' read word code instruction
doCODE                  cmp     threaded,fx wc        	' wordcode below threaded are cog or hubexex - just call
        if_nc           jmp     #doCALL			' just call if it is asm code - either cog or in hubexec range below wordcodes
                        cmp     coded,fx wc
        if_nc           jmp     #THREAD
                        cmp     shorts,fx wc          	' $FC00?
	if_nc           jmp     #doSHORT                ' LIT short 10-bit literal
                        cmp     branches,fx wc
        if_nc           jmp     #doBRANCH               ' IF UNTIL conditional reHIGHlative branch code
'
' REG OP ( -- addr ) - the 9-bit offset is relative to the regptr for that task
doREG                	zerox   fx,#8
                        add     fx,regptr
                        jmp     #doPUSHX
doSHORT        		zerox   fx,#9               	' push 10-bit literal
doPUSHX			call	#PUSHX
			jmp	#doNEXT

' Call wordcode - Save IP and load with new IP from call
'
THREAD			test    fx,#1 wz                ' bit0 is the jump/call bit
                        andn    fx,#1                   ' word align
        if_z            wrlut   PTRA,retptr             ' save IP onto return stack
        if_z            add     retptr,#1
                        mov     PTRA,fx                 ' jump to new wordcode (PTRA = IP)
                        jmp     #doNEXT

'
' Conditional with 7-bit signed word displacement
doBRANCH
                 	tjnz    tos,#dj1                ' discard flag and continue w/o jumping
                                                        ' take the jump - X has instruction wordcode
                        test    fx,#$80 wz              ' reverse jump? nz
                        and     fx,#$7F                 ' mask displacement
                        shl     fx,#1                   ' index as words
                        sumnz   PTRA,fx                 ' +/- jump
dj1                     call    #DROP                   ' discard condition flag
                        jmp     #doNEXT
{
			shl	fx,#24
			sar	fx,#23
			add	PTRA,fx

}

{
dPRTPA			mov	R1,PA
			jmp	#TXR1
}

'###################################################################################'


' 0EXIT ( flg -- ) Exit if flg is false (or zero)  Used in place of IF......THEN EXIT as false would just end up exiting
ZEXIT                   call    #POPX
        if_nz           ret
EXIT                    sub     retptr,#1
                _ret_   rdlut   PTRA,retptr


' ?EXIT ( flg -- ) Exit if flg is true
IFEXIT                  call    #POPX
        if_nz           jmp     #EXIT
                        ret

_ASM			call	PTRA
			jmp	#EXIT



AJMP                    mov     PTRA,tos                ' jump to address on top of the data stack
                        jmp     #DROP

ACALL                   call    #POPX                   ' get wordcode into X
                        pop     R1                      ' discard return address and jump back and use interpreter
                        jmp     #doCODE

' TAQOZ# " HELLO WORLD!" LAP LEN$ LAP .LAP --- 200 cycles= 833ns @240MHz ok
' LEN$ ( str -- len )
STRLEN
                        rdfast  #0,tos
                        mov     tos,#0
.L0                     rfbyte  R0			' read a byte
                        sub     R0,#1			' end is either a null or anything >$7F
                        cmp     R0,#$7E wc
        if_c            add     tos,#1
        if_c            jmp     #.L0
                        ret






{ *** STACK OPERATORS *** }

' NIP ( n1 n2 -- n2 ) : 600ns
NIP                     mov     tos1,tos
                        jmp     #DROP
' 3DROP ( n1 n2 n3 -- ) : 1.2us
DROP3                   call    #POPX
' 2DROP ( n1 n2 -- ) : 800ns
DROP2                   call    #POPX
' DROP ( n -- ) :48cy
DROP
' Pop the data stack using fixed size register stack in COG memory (allows fast direct access for operations)
' overflow stack in hub ram and reduces the size of the cog stack to 4
POPX ' wz
                        tjz     depth,#_NOP     ' don't pop beyond bottom of stack
                        mov     fx,tos wz       ' pop old tos into X
                        mov     tos,tos1
                        mov     tos1,tos2
                        mov     tos2,tos3
                        sub     depth,#1        ' maintain depth count
                        sub     datptr,#1       ' stack pointer
                _ret_   rdlut   tos3,datptr     ' pop from lut stack into register stack
_NOP                    ret


' ?DUP ( n1 -- n1 n1 | 0 ) DUP n1 if non-zero
QDUP                    tjz     tos,#_NOP
' DUP ( n1 - n1 n1 ) Duplicate the top item on the stack - 48 cycles
DUP                     mov     fx,tos                  ' Read directly from the top of the data stack
                        jmp     #PUSHX                  ' Push the internal X register onto the datastack

OVERPLUS	_ret_	add	tos,tos1

DUP2                    call    #OVER
' OVER ( n1 n2 -- n1 n2 n1 ) - 1us
OVER                    mov     fx,tos1                 'read second data item and push
                        jmp     #PUSHX
' tos2 ( n1 n2 n3 -- n1 n2 n3 n1 ) Copy the tos2 item onto the stack
THIRD                   mov     fx,tos2                 ' read third data item
                        jmp     #PUSHX
' 4TH ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 ) Copy the 4th item onto the stack - 1.2us
FOURTH                  mov     fx,tos3
                        jmp     #PUSHX


' BOUNDS ( n1 n2 -- n2+n1 n1 ) == OVER + SWAP
BOUNDS                  add     tos,tos1
' SWAP ( n1 n2 -- n2 n1 ) Swap the top two items
SWAP                    mov     fx,tos1
SWAPX                   mov     tos1,tos
PUTX            _ret_   mov     tos,fx

' -ROT ( a b c -- c a b )
ROT2                    call    #ROT
' ROT ( a b c -- b c a )
ROT                     mov     fx,tos2
                        mov     tos2,tos1
                        jmp     #SWAPX


{ *** ARITHMETIC *** }
' - ( n1 n2 -- n3 ) Subtract n2 from n1
MINUS                   neg     tos             ' (note: save one long by negating and adding)
' + ( n1 n2 -- n3 ) Add top two stack items together and replace with result
PLUS                    add     tos1,tos wc
                        jmp     #DROP

' 2-
DEC2            _ret_   sub     tos,#2
' 1-
DEC             _ret_   sub     tos,#1

' 4+
INC4            _ret_   add     tos,#4
' 2+
INC2            _ret_   add     tos,#2
' 1+
INC             _ret_   add     tos,#1

' -NEGATE ( n1 sn -- n1 | -n1 ) negate n1 if the sign of sn is negative (used in signed divide op)
MNEGATE                 shr     tos,#31
 ' ?NEGATE ( n1 flg -- n2 ) negate n1 if flg is true
QNEGATE                 tjz     tos,#DROP
                        call    #POPX
' NEGATE ( n1 -- n2 )  equivalent to  n2 = 0-n1
NEGATE          _ret_   neg     tos

{ *** BOOLEAN *** }
{
' INVERT ( n1 -- n2 ) bitwise invert n1 and replace with result n2
INVERT                  add     tos,#1
                        jmp     #NEGATE
}
' BITS ( n1 bits -- n2 )
BITS                    decod   tos
                        sub     tos,#1
_AND                    and     tos1,tos
                        jmp     #DROP
_ANDN                   andn    tos1,tos
                        jmp     #DROP
_OR                     or      tos1,tos
                        jmp     #DROP
_XOR                    xor     tos1,tos
                        jmp     #DROP
{
' mainly for testing instructions'
_ZEROX                  zerox   tos1,tos
                        jmp     #DROP
}
' *** shift operators ***

' *** RIGHT SHIFT ***
' SHR ( n1 cnt -- n2 ) Shift n1 right by count (5 lsbs )
_SHR                    shr     tos1,tos
                        jmp     #DROP

' 16>>
_SHR16          _ret_   shr     tos,#16
' 9>>
_SHR9           _ret_   shr     tos,#9
' 8>>
_SHR8           _ret_   shr     tos,#8

' 4/
_SHR2           _ret_   shr     tos,#2

' 2/ ( n1 -- n1/2 )
_SHR1           _ret_   shr     tos,#1


_RORQ                   ror     tos1,tos wc
                if_nc	mov	tos,#0
			ret



_ROR                    ror     tos1,tos
                        jmp     #DROP
_SAR                    sar     tos1,tos
                        jmp     #DROP


' *** LEFT SHIFT ***
' << ( n1 bits -- n2 )
_SHL                    shl     tos1,tos
                        jmp     #DROP

' ROL ( n1 bits -- n2 )
_ROL                    rol     tos1,tos
                        jmp     #DROP

_SHL16		_ret_	shl	tos,#16

_SHL9           _ret_   shl     tos,#9
' 8<<
_SHL8           _ret_   shl     tos,#8
' 4*
_SHL2           _ret_   shl     tos,#2
' 2* ( n1 -- n2 ) shift n1 left one bit (equiv to multiply by 2)
_SHL1           _ret_   shl     tos,#1

{
' REV>> 'P1 STYLE REV
_REVSHR			rev	tos1
			shr	tos1,#tos
			jmp	#DROP
}
' REV ( n1 -- n2 ) Reverse bits 0..31 --> 31..0
_REV            _ret_   rev     tos

'_BMASK                 bmask   tos

' MASK ( bitpos -- bitmask  \ only the lower 5 bits of bitpos are taken, regardless of the higher bits )
MASK            _ret_   decod   tos

' ENCODE ( mask -- bitpos )
ENCODE          _ret_   encod   tos

''      FAST MASKING
_AND1		_ret_	and	tos,#1
' 4BITS ( n -- nibble ) mask n to a nibble
BITS4           _ret_   and     tos,#$0F
' 8BITS ( n -- nibble ) mask n to a byte
BITS8           _ret_   and     tos,#$FF
' 9BITS
BITS9           _ret_   and     tos,#$1FF



OP2                     rol     tos1,tos	' INSTRUCTION FIELD IS SUBSTITUTED BEFORE USING'
                        jmp     #DROP



                        { *** COMPARISON *** }

' Basic instructions from which other comparison instructions are built from


' = ( n1 n2 -- flg ) true if n1 is equal to n2 :
_EQ                     call    #POPX
                        sub     tos,fx          ' n1 == 0 if equal
' 0= ( n -- flg ) true if n = 0  : 400ns @80
_ZEQ                    tjz     tos,#SETTRUE
                _ret_   mov     tos,#0

' 0<> ( n -- flg ) true if n <> 0 (promote n to boolean) : 400ns @80
_ZNE                    tjz     tos,#z1
SETTRUE         _ret_   mov     tos,M1
z1                      ret


' <> ( n1 n2 -- flg ) true if n1 <> n2 : 48cyc
_NEQ                    sub     tos1,tos wz
                if_nz   mov     tos1,M1
                        jmp     #DROP


' 0< ( n -- flg ) true if n < 0 (negative) : 32cyc
_ZLT            _ret_   sar     tos,#31

' NOT ( n -- !n ) invert bits of n : 350ns @80
_NOT            _ret_   not     tos


' ABS ( n -- abs )
_ABS            _ret_   abs     tos,tos

MUL16                   mul     tos1,tos
                        jmp     #DROP

' MOD ( n1 mod -- rem )
UMOD                    call    #UDIVMOD
                        jmp     #DROP


' signed MIN returns the minimum of the two values
_MINS                   fles    tos1,tos
                        jmp     #DROP
_MAXS                   fges    tos1,tos
                        jmp     #DROP
' unsigned MIN returns the minimum of the two values
_MIN                    fle     tos1,tos
                        jmp     #DROP
_MAX                    fge     tos1,tos
                        jmp     #DROP

{ *** MEMORY *** }

' C@++  ( caddr -- caddr+1 byte ) fetch byte character and increment address
CFETCHINC               mov     fx,tos                  ' dup the address
                        call    #PUSHX
                        add     tos1,#1                 ' inc the backup address
' C@  ( caddr -- byte ) Fetch a byte from hub memory : 500ns @80
CFETCH          _ret_   rdbyte  tos,tos

' DUPC@
DUPCFT                  rdbyte  fx,tos
                        jmp     #PUSHX                  ' Push the internal fx register onto the datastack



' W@  ( waddr -- word ) Fetch a word from hub memory
WFETCH          _ret_   rdword  tos,tos

' @  ( addr -- long ) Fetch a long from hub memory
FETCH           _ret_   rdlong  tos,tos


' C+!  ( n caddr -- ) add n to byte at hub addr : 1.2us @80
CPLUSST                 rdbyte  fx,tos                  ' read in word from adress
                        add     tos1,fx                         ' add to contents of address - cascade
' C!  ( n caddr -- ) store n to byte at addr : 1us @80
CSTORE                  wrbyte  tos1,tos                ' write the byte using address on the tos
                        jmp     #DROP2

' W+!  ( n waddr -- ) add n to word at hub addr
WPLUSST                 rdword  fx,tos                  ' read in word from address
                        add     tos1,fx
' W!  ( n waddr -- ) store n to word at addr
WSTORE                  wrword  tos1,tos
                        jmp     #DROP2

' +!  ( n addr -- ) add n to long at hub addr
PLUSST                  rdlong  fx,tos                  ' read in long from address
                        add     tos1,fx
' !  ( n addr -- ) store n to long at addr
STORE                   wrlong  tos1,tos
                        jmp     #DROP2



' LUT@ ( addr -- data ) : 400ns
LUTFETCH        _ret_   rdlut   tos,tos

' LUT! ( data addr -- ) : 900ns
LUTSTORE                wrlut   tos1,tos
                        jmp     #DROP2

COGFETCH                alts    tos,#0
                _ret_  	mov     tos,0_0

'' COG! ( long addr -- ) Store a long to cog memory
COGSTORE
                        altd    tos,#0
                        mov     0_0,tos+1
                        jmp     #DROP2


' BLOCK MOVE
'
' 171219 64K in 19.866ms using rep vs 24.872ms using djnz
' RCMOVE bytes from source to destination primitive - <CMOVE conditions the parameters before calling
' (RCMOVE) ( src dst cnt -- ) Copy bytes from src to dst for cnt bytes starting from the ends (in reverse)
pRCMOVE                 modcz   _set,0 wc  'modc    $0F wc          ' set carry for decrementing (always cleared by PUSH)
' (CMOVE) ( src dst cnt -- ) Copy cnt bytes from src to dst address
CMOVE                   rep     @.end,tos
                        rdbyte  R0,tos2         ' read source byte
                        sumc    tos2,#1         ' inc or dec depending upon carry
                        wrbyte  R0,tos1         ' write destination byte
                        sumc    tos1,#1         ' inc or dec depending upon carry!!
.end                    jmp     #DROP3


' Very fast block move uses SETQ2 and LUT to move chunks'
' LMOVE ( src dst longs -- )
LMOVE			mov	r0,tos
			fle	r0,#lmsz	' Limit to lmsz longs at a time
			sub	r0,#1		' adjust for setq
			setq2	r0		' read block of longs
			rdlong	lmbuf,tos+2
			setq2	r0		' write block of longs
			wrlong	lmbuf,tos+1
			add	r0,#1		' readjust
			sub	tos,r0 wcz	' update count
			shl	r0,#2		' hub addresses in bytes
			add	tos+2,r0	' update src and dst
			add	tos+1,r0
	if_nc_AND_nz	jmp	#LMOVE
			jmp	#DROP3

' ------------------------------------------------------------------------------

' wrfast rep code -> $6.0000 $1.0000 LAP ERASE LAP DECIMAL .LAP 131208 cycles = 1.640ms/64K
 ' ( addr bytes -- )
ERASE                   call    #PUSHACC
' ( addr cnt fillch -- )
CFILL                   wrfast  tos1,tos2
                        rep     @.L0,tos1
                        wfbyte  tos
.L0                     jmp     #DROP3
{
' Test for non-zero data in memory block
' DATA? ( addr longs -- flg )
DATAQ                   rdfast  #0,tos1
                        rep     @.L0,tos
                        rflong  fx
                        or      ACC,fx
.L0                     mov     tos1,ACC
                        jmp     #DROP
}


' I ( -- index ) read the loop index
IX                      mov     fx,index
                        jmp     #PUSHX
' J ( -- index ) read the loop index
J                       mov     fx,index2
                        jmp     #PUSHX
' IC@ ( -- byte )
ICFETCH                 rdbyte  fx,index
                        jmp     #PUSHX
' I+ ( n -- n+I ) fast index offset i.e.  table I+
IPLUS           _ret_   add     tos,index


{ *** BRANCH & LOOP *** }


' ADO = BOUNDS DO - just a quick and direct way as BOUNDS is most often never used elsewhere
' ADO ( from cnt -- )
ADO             call    #BOUNDS
'
                                                        ' DO ( to from -- )
DO              call    #SWAP
                call    #PUSHL                          ' PUSH index onto loop stack
'
                                                        ' FOR ( count -- ) Setup FOR...NEXT loop for count
'
FOR            wrlut   branchadr,braptr
                add     braptr,#1
                mov     branchadr,PTRA
' >L ( n -- ) Push n onto the loop stack
                jmp     #PUSHL

' L> ( -- n ) Pop n from the loop stack
LPOP            call    #LPOPX                          ' Pop loop stack into X
                jmp     #PUSHX                          ' Push X onto the data stack as tos

' +LOOP ( n1 -- )
PLOOP           call    #POPX                           ' get loop increment
                add     index,fx                                ' add to index
                sub     index,#1                        ' compensate so we can drop through to LOOP
' The comparison above is between the call insn (wr) at DELTA and the jump insn (nr) at POPX_ret,
' this will always be carry set. The call itself is indirect.
'
LOOP            add     index,#1                        ' increment index
                cmps    limit1,index wcz
BRANCH  if_a    mov     PTRA,branchadr                  ' Branch to the address that is saved in branch stack
        if_a    ret
                call    #LPOPX                          ' discard the limit
POPBRANCH       sub     braptr,#1
                cmp     braptr,#brastk wc
        if_c    mov     braptr,#brastk
                rdlut   branchadr,braptr
                jmp     #LPOPX                          ' discard the index
                                                                ' then next loop and its branch address

' ?NEXT ( flg -- index ) Same as NEXT except terminate early if flag is true and return with flag
QNEXT           mov     tos,tos wz
        if_nz   jmp     #POPBRANCH
                sub     index,#1 wcz
        if_nz   mov     PTRA,branchadr
        if_nz   jmp     #DROP                           ' discard flag and continye looping
                jmp     #POPBRANCH

' NEXT ( -- ) Decrement count (on loop stack) and loop until 0, then pop loop stack
forNEXT         djz     index,#POPBRANCH                ' exit loop
        _ret_   mov     PTRA,branchadr                  ' loop again


' LEAVE -  make the loop index = to the limit so that it will leave on the next LOOP
LEAVE           mov     index,limit1
        _ret_   sub     index,#1

{HELP >R ( n -- ) Push n onto the return stack }
PUSHR           wrlut   tos,retptr
                add     retptr,#1
                jmp     #DROP

{HELP R> ( -- n ) Pop n from the return stack }
RPOP            sub     retptr,#1
                rdlut   fx,retptr
                jmp     #PUSHX                          ' Push X onto the data stack as tos



LPOPX
                mov     fx,index
                mov     index,limit1
                mov     limit1,index2
                mov     index2,limit2
                sub     lpptr,#1
        _ret_   rdlut   limit2,lpptr

' 171231 - mod so that index is on top/last
' limit         -> index
' index         -> limit
' limit2        -> indexJ
' index2        -> limitJ
' stack

' >L ( tos -- ) Push tos onto the loop stack and drop tos
PUSHL
                wrlut   limit2,lpptr                    ' push bottom register to stack
                add     lpptr,#1
                mov     limit2,index2                   ' ripple registers
                mov     index2,limit1
                mov     limit1,index
                mov     index,tos
                jmp     #POPX


{ *** LITERALS *** }

' LITERALS are stored unaligned in big endian format which faciliates cascading byte reads to accumulate the full number

' ( -- 32bits ) Push a 32-bit literal onto the datastack by reading in the next 4 bytes (non-aligned)

_LONG                   rdlong  fx,PTRA++
                        jmp     #PUSHX

' Read an inline word literal and push it onto the stack
'
_WORD                   rdword  fx,PTRA++
                        jmp     #PUSHX


_TRUE
MINUS1          sub     ACC,#1
PUSHACC         mov     fx,ACC          ' Push the accumulator onto the stack then zero it
PUSHX           mov     ACC,#0          ' clear it for next operation
                wrlut   tos3,datptr     ' save bottom of register stack into lut memory
                add     datptr,#1
                mov     tos3,tos2       ' push 4 top items held in registers
                mov     tos2,tos1
                mov     tos1,tos
                mov     tos,fx          ' replace tos with X (DEFAULT)
                add     depth,#1        ' the depth variable indexes data in LUT
        _ret_   modcz   0,0 wc 		' clear C for some operations that use this to determine behaviour



{ *** CONSTANTS & VARIABLES *** }
{ Constants and variables etc are standalone fragments preceded by an opcode then the parameters,
either a long or the addess of the parameter field.
They are called from the main program and only use the IP to get the result.
}

DATCON                  nop                     ' This entry is used for constants that point to the DATA area - FORGETable by signature
CONL                    rdlong  fx,PTRA
                        call    #PUSHX
                        jmp     #EXIT
{
CONW			rdword  fx,PTRA
			call    #PUSHX
			jmp     #EXIT
}

' INLINE:
VARB                    mov     fx,PTRA
                        call    #PUSHX
                        jmp     #EXIT






{ *** SMART PINS *** }
{
WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#
WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#
WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#
RDPIN   D,S/#        - Get smart pin S/# result Z into D

V30
WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#, acknowledge pin
WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#, ack
WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#, ack
RDPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, ack
RQPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, don't ack
AKPIN   S/#        - Acknowledge pin S/#

}

' 160620-2300 - MODIFIED SMARTPIN OPS TO USE "pinreg" for faster access
' WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#, acknowledge pin
' WRPIN ( dst -- )
_WRPIN                  wrpin   tos,pinreg
                        jmp     #DROP


' WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#, ack
' WXPIN ( dst -- )
_WXPIN                  wxpin   tos,pinreg
                        jmp     #DROP


' WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#, ack
' WYPIN ( dst -- )
_WYPIN                  wypin   tos,pinreg
                        jmp     #DROP


' RDPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, ack
' RDPIN ( -- res )
_RDPIN                  rdpin   fx,pinreg
                        jmp     #PUSHX
_RDPINC                 rdpin   fx,pinreg wc
		if_c	sub	acc,#1
                        jmp     #PUSHACC

' RQPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, don't ack
' RQPIN ( -- res )
_RQPIN                  rqpin   fx,pinreg
                        jmp     #PUSHX


' AKPIN   S/#        - Acknowledge pin S/#
' AKPIN  ( -- )
_AKPIN          _ret_   wrpin   #1,pinreg

{
' BEGIN RDPIN $80 AND 0= UNTIL
WAITPIN                 rdpin   fx,pinreg
                        testb   fx,#7 wz
                if_nz   jmp     #WAITPIN
                        ret
}

WAITPIN			testp	pinreg wc
		if_nc	jmp	#WAITPIN
			ret


' TXDAT ( buf cnt -- )  write buffer direct to WYPIN
_TXDAT                  rdfast  #0,tos+1
''                      rep     @.end,tos
.L1                     rfbyte  fx
                        wypin   fx,pinreg
.wait                   testp   pinreg  wc              '..wait for buffer empty
        if_nc           jmp     #.wait
                        akpin   pinreg                  '..acknowledge pin
                        djnz    tos,#.L1
.end                    jmp     #DROP2



{ *** I/O ACCESS *** }


' Fast pin operations via PIN pinreg

' H - set the PIN high - fast as the parameter is in the pinreg
H               _ret_   drvh    pinreg

' L - set the PIN low - fast as the parameter is in the pinreg
L               _ret_   drvl    pinreg

_T              _ret_   drvnot  pinreg

' F - float pin
F               _ret_   dirl    pinreg
' R - read pin

R                       testp   pinreg wc
                if_c    sub     ACC,#1
                        jmp     #PUSHACC

' MSBOUT ( data pin -- data*2 pin )
MSBOUT			shl	tos1,#1 wc
		_ret_	drvc	tos
LSBOUT			shr	tos1,#1 wc
		_ret_	drvc	tos
LSBIN			testp	tos wc
		_ret_	shl	tos1,#1 wc
''			testp	tos wc
''			rlc	tos1,#1 wc


' normal pin operations via stack

' HIGH ( pin -- )
HIGH                    drvh    tos
                        jmp     #DROP
' LOW ( pin -- )
LOW                     drvl    tos
                        jmp     #DROP
' FLOAT ( pin -- )
_FLOAT                  dirl    tos
                        jmp     #DROP
' PIN@ ( bit -- state )
PINTEST                 testp   tos wc
                _ret_   muxc    tos,M1

M1                      long    -1


'************************************* SERIAL I/O **************************************
SEROUT		mov	txpin,tos
		jmp	#DROP

CONEMIT		mov	r1,tos
TXR1		mov	txpin,#tx_pin
                wypin   r1,txpin             '..send byte
		waitx	#0
.wait           testp   txpin         wc      '..wait for buffer empty
 if_nc          jmp     #.wait
                jmp     #DROP
txpin		long	tx_pin


'********************** SPI READ/WRITE *********************

' Read bytes in from SPI to memory
' SPI>BUF ( dst cnt -- sum ) 461.7us/512
SPIRX           wrfast  #0,tos1
                mov     tos1,#0
.L0             rep     @.end,#8                ' 8 bits
                 outnot  sck                     ' clock (low high or low high)
		 rcl     r1,#1                   ' shift in msb first
                 outnot  sck
		 nop
                 testp   miso wc                 ' read data from card
.end
		rcl     r1,#1                   ' shift in msb first
                wfbyte  r1
                djnz    tos,#.L0
                jmp     #DROP


' Read 32-bits from SPI'
SPIRDL
                rep     @sre1,#32
                skip    #1
' SPIRD ( dat -- dat+rd )
SPIRD
                rep     @sre1,#8                ' 8 bits
                 outnot  sck                     ' clock (low high)
RWAIT		 nop
                 outnot  sck
		 nop
                 testp   miso wc                 ' read data from card
                 rcl     tos,#1                  ' shift in msb first
sre1            ret


' Write bytes from memory to SPI '
' SPITX ( src bytes -- ) ' 474.6us/512
SPITXE		drvl	ss
          	drvl    sck
SPITX           rdfast  #0,tos1
.L0             rfbyte  fx
                shl     fx,#24
		mov	r1,#8
		call	#SPITX8
             	djnz    tos,#.L0
                jmp     #DROP2


' SMARTPINS? TRY CLOCKING ENABLED   C=1 in %CIOHHHLLL ?

' Write SD Command
SPIWRC		and     tos,#$3F
		or      tos,#$40
' SPIWR8 ( byte -- )
' Shift 8 bits from data[0..7] out and leave data on stack (restored with other bytes zeroed)
'
SPIWR8          shl     tos , #24               ' left justify 8-bit data s
		mov	r1,#8
SPIWR		drvl	ss
           	drvl    sck
		call	#POPX			' POP VALUE '
SPITX8		rep     @.L1,r1
                 rol     fx,#1 wc               ' output next msb
                 outc    mosi
                 outnot  sck                     ' clock
WWAIT		 nop
                 outnot  sck                     ' clock
.L1            ret


SPIWRL		mov	r1,#32
		jmp	#SPIWR
SPIWM		shl	tos,#8
		mov	r1,#24
		jmp	#SPIWR
SPIWR16		shl	tos,#16
		mov	r1,#16
		jmp	#SPIWR

SPICE  		drvh    ss
	_ret_	drvh	sck			' P2 shares clock as ce with other boot devices'




' I2C support
' CLKOUT ( iobit dat -- iobit dat2 ) REG6=iomask ) Shift msb bit out,  clock high, clock low
CLKOUT          outl    tos+1              ' ensure output will be active low
                drvl    clockpins
                shl     tos,#1 wc
                dirnc   tos+1                   ' make it an output if it is a low else float
' CLOCK ( REG6=iomask ) Toggle multiple bits on the output)
CLOCK           outnot  clockpins
                tjz     clkdly,#ckx
                mov     fx,clkdly
        _ret_   djnz    fx,#$
ckx             ret

' $01CA
' CLKIN ( iomask dat -- iomask dat2 )
CLKIN           dirl    tos+1
                testp   tos+1 wc
                rcl     tos,#1
                jmp     #CLOCK


' timing utility word
LAP             mov     lap2,lap1
        _ret_   getct   lap1



' DRAW VIDEO CHARACTER'
' WRCH ( font screen pen.paper )'
WRCH		mov	r0,tos
		shr	r0,#8		' r0 = pen, tos = paper'
		mov	ptrb,tos1
		mov	r1,#7
wrch1		rdbyte	fx,tos2		' read in next font char
		mov	r2,#6
		rep	@wrchx,#5
wrch2		shr	fx,#1 wc
  	if_c	wrbyte	r0,ptrb++
	if_nc	wrbyte	tos,ptrb++
wrchx		wrbyte	tos,ptrb++
		add	ptrb,##640-6
		add	tos2,#1
wrch3		djnz	r1,#wrch1
		jmp	#DROP3

ENDCOG
                fit 496			'' doesn't seem to work!!!!
		' TAQOZ COG CODE'
'******************************
'*  VGA 640 x 480 x 8bpp-lut  *
'
' PBJ: 181022 Adapted for TAQOZ
'
'******************************

CON
intensity	= 120				'0..128

bmpint		= $0				' 256 byte header - mostly free but top half may have bmp header written'
hcnt		= $4
vcnt		= $6
bmppal		= $100
bmppic		= $500

fclk		= float(CPUHZ)
fpix		= 25_000_000.0
fset		= (fpix / fclk * 2.0) * float($4000_0000)

DAT		org

vgainit
		call	#loadpal
		rdfast	##640*480/64,##bmporg+bmppic 'set rdfast to wrap on bitmap
''		setxfrq ##round(fset)
		'  cmod   65_4_321_0'		' VGA
		setcmod	#%01_0_000_0		'enable vga colorspace conversion
		rdbyte	x,#@_VGACFG		' read hsync
		wrpin	dacmode,x		'enable dac modes in selected pins
		dirh	x			' silicon needs dir set to enable smartpin'
		rdbyte	x,#@_VGACFG+1		' blue
		wrpin	dacmode,x
		dirh	x
		rdbyte	x,#@_VGACFG+2		' green
		wrpin	dacmode,x
		dirh	x
		rdbyte	x,#@_VGACFG+3		' red
		wrpin	dacmode,x
		dirh	x
		rdbyte	vsync,#@_VGACFG+4	' vsynch
'
' XCONT D31..16 = INSTRUCTION, D15..0 = NCO ROLLERS, S=SUB-MODE
' Field loop
'
field		mov	x,#33			'top blanks
		call	#blank

		mov     x,#480			'set visible lines
line		call	#hsync			'do horizontal sync
		xcont	m_rf,#0			'visible line
		djnz    x,#line           	'another line?

		mov	x,#10			'bottom blanks
		call	#blank
		drvnot	vsync			'sync on
		mov	x,#2			'sync blanks
		call	#blank
		drvnot	vsync			'sync off
		call	#loadpal		' continually update palette in case it has changed'
                jmp     #field                  'loop
'
' Subroutines
'
blank		call	#hsync			'blank lines
		xcont	m_vi,#0
	_ret_	djnz	x,#blank

hsync		xcont	m_bs,#0			'horizontal sync
		xcont	m_sn,#1
	_ret_	xcont	m_bv,#0

' Load palette from hub into lut '
loadpal
		rdlong	x,#@_vgaset
		setxfrq x		'set transfer frequency to 25MHz

		mov	x,#0
		rdfast	#0,##bmporg+bmppal 	'load .bmp palette into lut
		rep	@.end,#$100		' 256 colors
		rflong	y
		shl	y,#8
		wrlut	y,x
		add	x,#1
.end
		rdbyte	x,##bmporg+bmpint	' update intensity'
		shl	x,#8
		setcq	x
		shl	x,#8
		setci	x
		shl	x,#8
		setcy	x
		add	_vcnt,#1		' increment frame count'
		wrword	_vcnt,##bmporg+vcnt
		ret

' Initialized data
'			 1098_7654_321_0987654321098_76_54321_0
'			%AAAA_BBBB_FFF_DACxxDDDDDDDD_TT_MMMMM_0
dacmode		long	%0000_0000_000_1010000000000_01_00000_0+vgacog<<8

' $CF00 = output X3, X2, X1, X0 on all four DAC channels'
m_bs		long	$CF000000+16		'before sync  %1100_dddd_eppp_xxxx <long> 32-bit immediate
m_sn		long	$CF000000+96		'sync
m_bv		long	$CF000000+48		'before visible
m_vi		long	$CF000000+640		'visible

m_rf		long	$7F000000+640		'visible rflong 8bpp lut

vsync		res	1
x		res	1
y		res	1
_vcnt		res	1
		' VGA COG CODE'

'
'***************************************** HUBEXEC CODE ***************************
'

		orgh
		alignl


_hubexec

' !SP - init the data stack pointer
INITSP
        	mov     datptr,#datstk
        _ret_   mov     depth,#0
''   	_ret_	mov     tos,##$DEADBEEF         	' marker

INITSTKS        call    #@INITSP

INITLP          mov     lpptr,#lpstk
                mov     braptr,#brastk
INITRP
 	_ret_   mov     retptr,#retstk

READRX		rdword	r0,#@rxrd
		cmp	r0,rxwrC wz
	if_z	jmp	#PUSHACC	''@rr1
		mov	r1,r0
		add	r1,##rxbuffers
		rdbyte	acc,r1
		incmod	r0,##rxsize-1
		wrword	r0,#@rxrd
rr1		jmp	#PUSHACC



DEBUGGER	ret
		setint1	#0
'''		jmp 	#\_Start_Monitor	' \ forces absolute address '


{
SLOWK		rdlong	fx,##SLOWCALL
SETSPI		mov	RWAIT,fx
		mov	WWAIT,fx
		jmp	#EXIT
FASTK		mov	fx,#0
		jmp	#SETSPI
SLOWCLK		waitx	#511
		outnot  sck
		waitx	#511
		ret
SLOWCALL	call	#\SLOWCLK
}

' Registers can be used just like variables and the interpreted kernel uses some for itself
' 128+ bytes are reserved. Since the registers are pointed to by "regptr" they can relocated
' REG ( index -- addr ) Find the address of the register
ATREG   _ret_           add     tos,regptr

LAPFETCH                mov     fx,lap1
                        sub     fx,lap2
                        jmp     #pushx

' COGSTOP ( cog -- )
_COGSTOP                cogstop tos
                        jmp     #DROP

' COGINIT ( addr cog -- )
                        coginit tos,tos1
                        jmp     #DROP2

' COGATN ( mask -- )
_COGATN                 cogatn  tos
                        jmp     #DROP

' POLLATN ( -- flg )
_POLLATN                pollatn wc
                if_c    sub     acc,#1
                        jmp     #PUSHACC

'' SETEDG ( edge pin -- ) add 4 to edge for lock
_SETEDG                 shl     tos+1,#6
                        add     tos,tos+1
                        setse1  tos
                        jmp     #DROP2

'' POLLEDG ( -- flg )
_POLLEDG                pollse1 wc
                if_c    sub     acc,#1
                        jmp     #PUSHACC

WAIT ''( clks -- )
                        waitx   tos
                        jmp     #DROP

_GETCNT                 GETCT   fx
                        jmp     #PUSHX


'PASM			call	PTRA


' some smartpin support for high level
' @PIN ( -- pin )
_ATPIN                  mov     fx,pinreg
                        jmp     #PUSHX

'' PIN ( pin -- )
_PIN                    mov     pinreg,tos
                        jmp     #DROP

_CLK                    mov     tepin,tos
                        jmp     #DROP

' WRACK ( data -- )     Write smartpin data and wait for empty then ack
WRACK                   wypin   tos,pinreg
.wait                   testp   pinreg  wc              '..wait for buffer empty
        	if_nc   jmp     #.wait
                        akpin   pinreg                  '..acknowledge pin
                        jmp     #DROP

_RND                    xoro32  seed
                        mov     fx,seed
                        jmp     #PUSHX

' SKIPNZ ( flg -- ) Skip if flg is true ( replace 0= IF xxx THEN )
SKIPNZ                  tjz     tos,#.L0
                        add     PTRA,#2
.L0                     jmp     #DROP



' > ( n1 n2 -- flg )
GT                      cmps    tos,tos1 wc
                        jmp     #CFLG
' < ( n1 n2 -- flg )
LT                      cmps    tos1,tos wc
                        jmp     #CFLG
' U< ( u1 u2 -- flg )
_ULT                    cmp     tos1,tos wc
CFLG                    subx    tos1,tos1
                        jmp     #DROP

'' a=tos,b=tos1,c=tos2,d=tos3
'' b++
bINC		_ret_	add	tos1,#1

'''''''''''''' CORDIC '''''''''''''
'
' cordic moved to hubexec since there is only a few cycles penalty due to pipeline
'
'
MULTIPLY                qmul    tos,tos1
                        getqx   tos1
                        jmp     #DROP

' UM* ( u1 u2 -- ud. )
' DESC: unsigned 32bit * 32bit multiply -- 64bit result
UMMUL                   qmul    tos,tos1
                        getqx   tos1
                _ret_   getqy   tos

' U// ( dvdn dvsr -- rem quot )
UDIVMOD                 qdiv    tos1,tos
                        getqx   tos
                _ret_   getqy   tos1


' U/ ( u1 u2 -- quot )
UDIVIDE                 qdiv    tos1,tos
                        getqx   tos1
                        jmp     #DROP


' SQRT ( d. -- sqrt )
_SQRT                   qsqrt   tos1,tos
                        getqx   tos1
                        jmp     #DROP



{
' ': DM* ( d. n -- d. )	-ROT SWAP 3RD UM* ROT 4TH * + ROT DROP ;
DMMUL	word	ROT2,SWAP,THIRD,UMMUL,ROT,FOURTH,MULTIPLY,PLUS,ROT,DROP,EXIT
FETCH2	word	DUP,FETCH,SWAP,INC4,FETCH,EXIT
STORE2	word	SWAP,OVER,INC4,STORE,STORE,EXIT
}
{
'' D! ( d. addr -- )
STORE2 			wrlong	tos2,tos
			add	tos,#4
			wrlong	tos1,tos
			jmp	#DROP3
'' D@ ( addr -- d. )
FETCH2			rdlong	r1,tos		' read low 32-bits
			add	tos,#4
			rdlong	fx,tos		' read high '
			mov	tos,r1		' set low'
			jmp	#PUSHX		' push high

' D+ ( d1. d2. -- d3. )
DPLUS			add	tos3,tos1 wc
			addx	tos2,tos
			jmp	#DROP2

DSUB			sub	tos3,tos1 wc
			subx	tos2,tos
			jmp	#DROP2

}


''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' main division sub - called both by U/ and U//
' double div, single divisor
' By specifing bits and left justifying the routine can be adapted and run faster
' CLKHZ 1234 LAP U// LAP .LAP  27.400us ok --> 18.800us
' UM//
' UM/MOD64 ( Dbl.dividend divisor -- remainder Dbl.quotient)
UMDIVMOD64      mov     ACC,#32
UMDIVMOD32      add     ACC,#32
                mov     R0, tos         ' R0 = divisor
                mov     R1, tos2                ' R1R2 = dividend
                mov     R2, tos1
                mov     tos2, #0                                ' remainder

udmlp           shl     R1, #1 wc                       ' dividend msb
                rcl     R2, #1 wc
                rcl     tos2, #1                        ' hi bit from dividend
                cmpsub  tos2, R0   wc                   ' cmp divisor ( R0 - tos & c set if tos => R0 )
                rcl     tos1, #1 wc                             ' R1 = quotient l
                rcl     tos, #1                         ' R2 = quotient h
        _ret_   djnz    ACC,#udmlp

' DSWAP ( n1 n2 n3 n4 -- n3 n4 n1 n2 )
DSWAP                   mov     R0,tos
                        mov     R1,tos1
                        mov     tos,tos2
                        mov     tos1,tos3
                        mov     tos2,R0
                _ret_   mov     tos3,R1


SPIPINS ' ( long --- ) sets bit numbers for SPI mode from bytes in long as cs.mi.mo.ck
		getbyte	sck,tos,#0
		getbyte	mosi,tos,#1
		getbyte	miso,tos,#2
		getbyte	ss,tos,#3
		drvl    sck              ' clock high/low ? (testing)
		drvh    ss               ' chip select high
		drvh    mosi             ' mosi high
		drvl    ss		 ' pulse cs to clock other device
		dirl    miso             ' input
		drvh    ss
		jmp     #DROP


' CLKS ( cnt -- )'
CLKS		drvl	sck		' idle low
		drvh	mosi		' with MOSI high '
		shl	tos,#1		' 2 edges/clock'
.l1		drvnot	sck
		djnz	tos,#.l1
		jmp	#DROP

{
PAFETCH                 mov     fx,INA
                        jmp     #PUSHX
PBFETCH                 mov     fx,INB
                        jmp     #PUSHX
PASTORE                 mov     OUTA,tos
                        jmp     #DROP
PBSTORE                 mov     OUTA,tos
                        jmp     #DROP
DACLR                   andn    DIRA,tos
                        jmp     #DROP
DBCLR                   andn    DIRB,tos
                        jmp     #DROP
' ( mask -- )
PASET                   or      OUTA,tos
DASET                   or      DIRA,tos
                        jmp     #DROP

PBSET                   or      OUTB,tos
DBSET                   or      DIRB,tos
                        jmp     #DROP

PACLR                   andn    OUTA,tos
                        jmp     #DASET
PBCLR                   andn    OUTB,tos
                        jmp     #DBSET
}

{ *** COG ACCESS *** }



_COGID                  cogid   fx
                        jmp     #PUSHX


'' _COGINIT ( dest cog -- )
_COGINIT                coginit tos,tos1
                        jmp     #DROP2

'' DELTA ( delta -- )   Calculate and set the cnt delta and waitcnt
DELTA                   call    #POPX
                        mov     deltaR,fx
'' WAITCNT ( -- )
WAITCNTS        _ret_   waitx   deltaR          '' continue from last count (must be called before target is reached)

{
_SETSE1			setse1	tos
			jmp	#DROP
_SETSE2			setse2	tos
			jmp	#DROP
_SETSE3			setse3	tos
			jmp	#DROP
_SETSE4			setse4	tos
			jmp	#DROP
_WAITSE1	_ret_	waitse1
_WAITSE2	_ret_	waitse2
_WAITSE3	_ret_	waitse3
_WAITSE4	_ret_	waitse4

}


{

' OUTCLR ( iomask  -- ) Clear multiple bits on the output
OUTCLRA         andn    OUTA,tos
                or      DIRA,tos
                jmp     #DROP

'' OUTSET ( iomask  -- ) Set multiple bits on the output
OUTSETA         or      OUTA,tos
 ' OUTPUTS ( iomask  -- ) Set selected port pins to outputs
                or      DIRA,tos
                jmp     #DROP


' INPUTS ( iomask -- ) Set selected port pins to inputs
INPUTSA         andn    DIRA,tos
                jmp     #DROP

}


{
' VCH ( pen.paper scr' font' )' 5.576us @300MHz
WRCH		mov	r0,tos2
		shr	r0,#8		' r0 = pen, tos2 = paper'
		mov	ptrb,tos1
		mov	r1,#7
wrch1		rdbyte	fx,tos		' read in next font char
		mov	r2,#5		' 5 pixels/line'
wrch2		shr	fx,#1 wc
  	if_c	wrbyte	r0,ptrb++
	if_nc	wrbyte	tos2,ptrb++
		'add	tos1,#1
		djnz	r2,#wrch2
		wrbyte	tos2,ptrb++
		add	ptrb,##640-6
		add	tos,#1
		djnz	r1,#wrch1
		jmp	#DROP3
}

' L2S ( n -- lsb9 h ) specialized operation for filesystem addresses ( splits off 9 lsbs )
L2S                     mov     fx,tos
                        and     tos,#$1FF
                        shr     fx,#9
                        jmp     #PUSHX

' L2W   word    DUP,TOW,SWAP,_SHR16,EXIT

{
' SHIFT from INPUT - Assembles with last bit received as msb - needs SHR to right justify if asynch data
' SHRINP ( pin dat -- pin dat/2 )
SHRINP                  testp   tos1 wc
                        rcr     tos,#1
                        ret
}
{ SHIFT to OUT -
This is optimized for when you are sending out multiple bits as in asynchronous serial data or I2C
Shift data one bit right into output via iomask - leave mask & shifted data on stack (looping)
400ns execution time including wordcode read and execute  or 200ns/bit with REPS }
{
' SHROUT ( pin dat -- iomask dat/2 )

SHROUT
                        shr     tos,#1 wc       ' Shift right and get lsb
                        drvc    tos1
                        ret
}

BITST                   call    #POPX
                        tjz     fx,#CLR
' SET ( mask addr -- ) Set bit(s) in hub long
SET                     rdlong  fx,tos
                        or      fx,tos1
                        wrlong  fx,tos
                        jmp     #DROP2

' CLR ( mask addr -- ) Clear bit(s) in hub long
CLR                     rdlong  fx,tos
                        andn    fx,tos1
                        wrlong  fx,tos
                        jmp     #DROP2

' SET? ( mask addr -- flg ) Test single bit of a long in memory
BITQ                    rdlong  tos,tos
                        and     tos1,tos wz
        if_nz           mov     tos1,M1
                        jmp     #DROP



' ~~ ( addr -- )                set long
SETL                    sub     ACC,#1
' ~ ( addr -- )                 clear long
CLRL                    wrlong  ACC,tos
                        jmp     #DROP

' W~~ ( addr -- )               set word
SETW                    sub     ACC,#1
' W~ ( addr -- )                clear word
CLRW                    wrword  ACC,tos
                        jmp     #DROP

' C~~ ( addr -- )               set byte
SETC                    sub     ACC,#1
' C~ ( addr -- )                clear byte
CLRC                    wrbyte  ACC,tos
                        jmp     #DROP
{
' M* ( 32b 16b -- 32b )'
MUL3216			mov	prod, v1
			sar	prod, #16
			mul	prod, v2
			shl	prod, #16
			mul	v1, v2
			add	prod, v1
			jmp	#DROP
}

DZEQ			mov	fx,tos
    			or	fx,tos1 wz
		if_z	sub	fx,#1
		if_nz	mov	fx,#0
			jmp	#PUSHX


' Inline vector check and exeute  !!!! needs to be able to handle hubexec !!!!
' ?JMP ( adr -- )

QJMP                    rdword  fx,tos wz       ' read contents of vector
                if_nz   mov     PTRA,fx
                        jmp     #DROP



{
_INCMOD '( mod dst -- )
                incmod  tos,tos+1
                jmp     #DROP2
}

_SETDACS	setdacs	tos
		jmp	#DROP


_GETRND         getrnd  fx
                jmp     #PUSHX

_HUBSET
                hubset  tos
                jmp     #DROP


{

' WS2812 ( array ledcnt -- ) pin is in cog "pinreg" - line RET is done at HL, not here
' Will transmit a whole array of 24-bit words each back to back in WS2812 timing format
' line idles low and resets/synchs with low =>50us
' A zero is transmitted as 400ns high by 850ns low (+/-150ns)
' A one is transmitted as 800ns high by 450ns low HHL
' The low period between each led is about 400ns longer but inconsequential
' <30us/LED
wsdly 	      long	sys_clk/2500000
WSLED	      rdbyte 	r2,##wsdly
              sub       tos1,#1         ' offset for 24-bit long alignment
.l2           rdlong    fx,tos1          ' read next long
              add       tos1,#3         ' but leds are 3 bytes apart
              mov       r1,#24          ' write all 24 bits
.lp
              shl       fx,#1 wc         ' get next bit
              drvh      pinreg          ' always clock tx pin high for at least 400ns
              waitx     r2              ' 400ns
              drvc      pinreg          ' output data bit
              waitx     r2              ' delay again, (data is either high or low)
              drvl      pinreg          ' always needs to go low in the last third of the cycle
              waitx     r2 '-20'
              djnz      r1,#.lp
              djnz      tos,#.l2        ' read the next long as long as we can (tos = count)
              jmp       #DROP2          ' tx line left low to synch - discard stack parameters, all done.

}


{
' VER ( -- verptr )
GETVER          loc     PA,#@version
                mov     fx,PA
                jmp     #PUSHX
}

{
DICTIONARY
00.D000: 03 44 55 50 6B 00 04 32 44 55 50 6D 00 04 4F 56    .DUPk..2DUPm..OV
00.D010: 45 52 6E 00 04 44 52 4F 50 61 00 05 32 44 52 4F    ERn..DROPa..2DRO
00.D020: 50 60 00 04 53 57 41 50 75 00 05 32 53 57 41 50    P..SWAPu..2SWAP
00.D030: 50 0D 03 52 4F 54 7A 00 04 2D 52 4F 54 79 00 03    P..ROTz..-ROTy..
}
{
 ATR(765):CNT(43210),<NAME>,CFA '
' Find string in dictionary is written in code and takes around 1us/word
' r3 = cnt+1st char of source '
        '    r1   r2  '
}
FINDSTR '  ( cstr dict -- nfaptr | false )
                rdword  r3,tos1                 ' read in count and 1st char
fstlp           mov     r2,tos                  ' R2 = dict word ptr '
                mov     r1,tos1                 ' R1 = source
                rdword  fx,r2 wz                ' read in count + 1st char'
        if_z    jmp     #fstfail                ' end of dictionary?'
                andn    fx,#$E0                 ' mask out atrs from count
                cmp     fx,r3   wz              ' compare count+1st char '
        if_nz   jmp     #fstskip                ' no match, go to next word
                mov     r4,r3                   ' matched on cnt + 1st char'
                and     r4,#cntm                ' now match rest if needed'
                sub     r4,#1 wz                ' matched if single else setup'
        if_z    jmp     #fstmatch
                add     r1,#2                   ' skip into 2nd char'
                add     r2,#2
fstrem          rdbyte  r0,r1                   ' read in char from source '
                add     r1,#1                   ' hub has to wait anyway so get ready for next source byte
                rdbyte  fx,r2                   ' read in a character from the dictionary
                add     r2,#1
                cmp     fx,r0 wz                        ' are they the same?
         if_nz  jmp     #fstskip                ' skip if not same'
                djnz    r4,#fstrem              ' continue for remainder'
fstmatch        mov     tos1,tos                ' NIP
                jmp     #DROP                   ' found it
fstskip         rdbyte  fx,tos                  ' read cnt to skip to next header '
                and     fx,#cntm                        ' 03,D,U,P,CFAL,CFAH
                add     tos,fx
                add     tos,#3                  ' skip over CPA to next header'
                jmp     #fstlp
fstfail         mov     tos1,#0
                jmp     #DROP

_DEPTH          mov     fx,depth
                jmp     #PUSHX

{
REGVAR          POP     fx
                rdbyte  fx,fx
                add     fx,regptr
                jmp     #PUSHX
}
{
        "   ABCDEFGHIKLMNOPQRSTUVWXYZ$@!+- _abcdefghijklmnopqrstuvwxyz{|}~ #J%&'()*,./0123456789:;<=>?[\]^"
        0 -ROT BEGIN DUP C@ WHILE OVER OVER C@ = IF 2DROP EXIT THEN ROT 1+ -ROT 1+ REPEAT
        ;
}
{
' LOOKIN ( val array -- index )
LOOKIN          mov     R1,tos1
                mov     tos1,#0                         ' init result index
.L0             rdbyte  fx,tos wz
        if_z    mov     tos1,#0
        if_z    jmp     #DROP
                add     tos1,#1                         ' inc result index
                cmp     fx,R1 wz
        if_z    jmp     #DROP
                add     tos,#1
                jmp     #.L0

_LOOKUP '( index array -- value )
                add     tos1,tos
                rdbyte  tos1,tos1
                jmp     #DROP
}

NEWCOG		coginit tos,##@RESET
		jmp	#DROP



{

dPRTIP		call	#dCRLF
''		mov	P,PTRA
''		shr	P,#16
		call	#dPRTWORD
		mov	P,PTRA
		jmp	#dPRTWORD

dPRTX		mov	R1,#$20
		call	#TX
		mov	P,fx
dPRTWORD
		mov	R1,P
		shr	R1,#12
		call	#HEXASC
		mov	R1,P
		shr	R1,#8
		call	#HEXASC
		mov	R1,P
		shr	R1,#4
		call	#HEXASC
		mov	R1,P
		call	#HEXASC
		mov	R1,#$20
		call	#TX
		ret
'
HEXASC		and	R1,#$0F
		add	R1,#$30
		cmp	R1,#$3A wc
	if_nc	add	R1,#7
TX
		wypin	R1,#tx_pin		'..send byte
.wait		testp	#tx_pin		wc	'..wait for buffer empty
 if_nc		jmp	#.wait
		akpin	#tx_pin			'..acknowledge pin
		waitx	#200
		ret

dCRLF		mov	R1,#$0D
		call	#TX
		mov	R1,#$0A
		jmp	#TX
'}


endcode
		'HUBEXEC CODE AFTER WORDCODE '
InitSerial
		drvh	#tx_pin
		wrpin	#$7C,#tx_pin			' asynchronous transmit
		wrpin	#$3E,#rx_pin			' asynchronous receive
'SETBAUD 						' calculate baud timing at runtime'
		rdlong	r0,#@_CPUHZ
		rdlong	r1,#@_BAUD
		qdiv	r0,r1
		getqx	r0
		shl	r0,#16
		add	r0,#7				' 8 data bits '
		wxpin	r0,#rx_pin			' baud 8 data
		wxpin	r0,#tx_pin			' baud 8 data
		wypin   #$0D,#tx_pin
		rdlong	PTRA,#@_TERMINAL
		dirh    #rx_pin				' enable smartpin mode'
		rdpin	rxz,#rx_pin wc			' clear rx?
		setint1	#0				' disable int0'
		mov 	rxwrC,#0
		wrlong 	rxwrC,#@rxrd

		setse1  #%110<<6+rx_pin        		' set se1 to trigger on  rx char event?????
                mov     ijmp1,##@taqoz_rxisr     	' set int1 jump vector to receive buffer
		setint1	#4				' Enable int0 to trigger on se1'
		ret

' ( SERIAL RECEIVE INTERRUPT SERVICE ROUTINE )'
taqoz_rxisr	shl 	rxlong,#8
                rdpin   rxz,#rx_pin       		' recv byte (bits31:24) from rx pin
		shr	rxz,#24				' right justify'
		or	rxlong,rxz wz			' update history word'
		cmp	rxlong,##$1B1B1B1B wz		' check for sequence'
	if_z	coginit #0,#0	''@_RESET		' force reset '

		cmp	rxlong,##$1A1A1A1A wz		' check for sequence '
	if_z	decod	rxz,#28				' reboot via hub'
	if_z	hubset	rxz
		mov	rxwrP,rxwrC			' update write pointer'
		add	rxwrP,##rxbuffers
		wrbyte	rxz,rxwrP			' write char to buffer'
		wrbyte	rxz,#@lastkey			' write directly to global variable in low hub'
		incmod	rxwrC,##rxsize-1		' update write index'
		wrword	rxwrC,#@rxwr			' update write index in hub'
		reti1



                orgh

THREADS
{ *** OUTPUT OPERATIONS *** }

SPACE   word    _BL
EMIT    word    rg+linenum,WFETCH
        word    _IF+06,DUP,w+$0A,_EQ,_IF+02,DROP,_13
        word    rg+uemit,QJMP
        word    CONEMIT,EXIT

SPACES3	word	_3
SPACES  word    _BL,SWAP
'
' EMITS ( ch cnt -- )
EMITS   word    QDUP,_IF+04,FOR,DUP,EMIT,forNEXT,DROPEX+ex

' ?EMIT ,( ch --  ) suppress emitting the character if echo flag is off
QEMIT
        word    w+echo,CHKFLG,SKIPZ,EMIT+ex
DROPEX  word    DROP,EXIT


_CON    word    rg+uemit,CLRL,EXIT

' direct output to a smartpin (after init)
_COM    word    _PIN,_WORD,WRACK
SETEMIT word    rg+uemit
WSTOREX word    WSTORE,EXIT

NONE    word    w+DROP,SETEMIT+ex

SETKEY  word    rg+ukey,WSTOREX+ex

CLS     word    w+$0C,EMIT+ex
BELL    word    w+7,EMIT+ex

SPINNER word    rg+spincnt,CFETCH,_3,_SHR,_3,_AND
        word    _STRING
        byte    "|/-\ ",0
        word    PLUS,CFETCH
        word    EMIT,_8,EMIT,rg+spincnt,CINC,_1,ms+ex

' ACCEPTED
OK      word    PRTSTR
        byte    " ok",0
CRLF    word    CR
LF      word    w+$0A,EMIT+ex

CR      word    _13,EMIT+ex

' emit printable ASCII or a dot otherwise
AEMIT   word    QCHAR,_ZEQ
        word    _IF+02,DROP
DOT     word    w+".",EMIT+ex
SCORE   word    w+"_",EMIT+ex
PRTTICK	word	w+"'",EMIT+ex


CHKFLG  word    rg+fflags,BITQ,EXIT
CLRFLG  word    rg+fflags,CLR,EXIT
SETFLG  word    rg+fflags,SET,EXIT


' U>    SWAP U< ;
UGT     word    SWAP,_ULT,EXIT
' <=    ( n1 n2 -- flg )
LTEQ    word    SWAP
' =>    ( n1 n2 -- flg  )       1- > ;
EQGT    word    DEC,GT,EXIT


DIVIDE  word    OVER,_ABS,OVER,_ABS,UDIVIDE,ROT2,_XOR,MNEGATE,EXIT


' */ ( u1 u2 div1 -- res )
' CLKHZ 1.333333 1,000,000 LAP */ LAP .LAP  35.200us ok
MULDIV  word    ROT2,UMMUL,ROT,UMDIVMOD64,DROP,NIP,EXIT


' C--
CDEC    word    MINUS1,CINC+2+ex
' C++
CINC    word    _1,SWAP,CPLUSST,EXIT

' W--
WDEC    word    MINUS1,WINC+2+ex
' W++
WINC    word    _1,SWAP,WPLUSST,EXIT

' --
LDEC    word    MINUS1,LINC+2+ex
' ++
LINC    word    _1,SWAP,PLUSST,EXIT


FETCHX  word    FETCH,EXIT





''''''''''''''''''' CONSTANTS '''''''''''''''''''''

W1000000
        word    CONL
        long    1000000
W1000   word    CONL
        long    1000

CLKHZ   word	w+$14,FETCH,EXIT
CLKMHZ  word    CLKHZ,_LONG
	long	1000000
	word	UDIVIDE,EXIT



BUFFERS word    CONL
        long    SDBUFS	''$F000
ROM     word    CONL
        long    $0F_C000
IRQVEC  word    CONL
        long    $0F_FFE0


{
%0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS     Set clock generator mode
%0001_0000_0000_0000_0000_0000_0000_0000     Hard reset, reboots chip
%001P_0000_0000_0000_0000_0000_0000_0000     Set write-protect of last 16KB RAM to P
%01RR_0000_0000_0000_0000_0000_0LLT_TTTT     Set filter R to length L and tap T
%1DDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD     Seed Xoroshiro128+ PRNG with D
}

REBOOT  word    w+1,HUBSW+ex
WE      word    w+2,HUBSW+ex
WP      word    w+3
HUBSW   word    w+28,_SHL
HUBEX	word	_HUBSET,EXIT

' 1=80MZ 2=40MHZ 3=20MHZ 4=10MHZ 5=5MHZ
CLKDIV  word    _1,_MAX,w+$1FF,SWAP,_SHR,HUBEX+ex
RCSLOW  word    _1,HUBEX+ex

{
pub 50MHZ       $9F HUBSET ;
pub 45.4MHZ     $8F HUBSET ;
pub 62.5MHZ     $C7 HUBSET ;
}






''''    BEGIN as in BEGIN...AGAIN or BEGIN...UNTIL  generate branch for BEGIN
_BEGIN_ word    ATCODES,w+$BE
'''
''' MARK ( addr tag -- tag&addr ) Merge tag and addr by shifting tag into hi word
MARK    word    w+24,_SHL
ORX	word	_OR,EXIT

' UNMARK        ( tag&addr -- addr tag )
UNMARK  word    DUP,MINUS1,_SHR8,_AND,SWAP,w+24,_SHR,EXIT



''' REPEAT if mark is $1F preceded by $BE mark
_REPEAT_
        word    SWAP,_AGAIN_,_THEN_+ex

''' AGAIN if mark is $BE
_AGAIN_
__AGAIN word    UNMARK
        word    w+$BE,_EQ,_IF+(badthen-ag1)/2
        ' ( addr bc -- ) compile the wordcode and calculate the branch back
ag1     word    INC,COMPW+ex

''' UNTIL ( flg -- )
_UNTIL_ word    UNMARK
unt00   word    w+$BE,_EQ,_IF+(badthen-unt1)/2
unt1    word    ATCODES,SWAP,MINUS,_SHR1,INC
        word    _WORD,_UNTIL,_OR,COMPW+ex



''' IF as in IF...THEN or IF...ELSE...THEN
''' WHILE
_IF_
        word    ATCODES,w+$1F,MARK
        word    _WORD,_IF,COMPW+ex                      ' compile an IF and a dummy branch (else/then will set)

GOTO    word    ATCODES,w+$1E,MARK
        ''      compile a dummy NOP to be replacd later with a goto (addr+ex)
        word    w+_NOP,COMPW+ex

' ELSE
_ELSE_
        word    UNMARK ' ( addr tag )
''              does this match an IF?
        word    w+$1F,_EQ,_IF+(badthen-.L0)/2
''              mark the else to be processed on a THEN
.L0     word    GOTO
'
''              get the IF addr and proceed as if it were a THEN
        word    SWAP,w+$1F,MARK
' THEN
_THEN_	word	ATCODES,w+athen,WSTORE
  	word    UNMARK '( addr tag )
        '
        ' ( addr tag ) resolve structure branch
        ''      ELSE THEN ?
        word    DUP,w+$1E,_EQ,_IF+05
        word    DROP,ATCODES,INC,SWAP,WSTOREX+ex
        ''      IF THEN ?
        word    w+$1F,_EQ,_IF+8
        ''      update IF's branch
        word    ATCODES,OVER,MINUS,_SHR1,DEC,SWAP,CSTOREX+ex
        '
badthen word    PRTSTR
        byte    " Structure mismatch! ",0
        word    ERROR,DROPEX+ex



''''''''''''''''''''' STRINGS ''''''''''''''''''''''''''




' NULL$
NULLSTR word    VARB,0

' $! ( str1 str2 -- )
STRST   word    OVER,STRLEN,INC,CMOVE,EXIT

' $= ( str1 str2 -- flg )
STREQ   word    OVER,STRLEN,OVER,STRLEN,_EQ
        word    _IF+14,DUP,STRLEN,ADO
	word	CFETCHINC,IX,CFETCH,_NEQ,_IF+03,DROP,_0,LEAVE,LOOP,_ZNE,EXIT
        word    DROP2,_FALSE,EXIT	''+ex


' STR ( -- n ) Leave address of inline string on stack and skip to next instruction
_STRING word    RPOP,DUP,STRLEN,OVERPLUS,INC,WALIGN,AJMP


' " string"     Compile a literal string - no length restriction - any codes can be included except the delimiter "
_STRING_
        ''      compile wordcodes for string
        word    _WORD,_STRING,COMPW,COMPSTR+ex


PRTSTRN	word	CRLF
' Print inline string
PRTSTR  word    RPOP
.lp     word    CFETCHINC,QDUP,_IF+02,EMIT,.lp+ex
        word    WALIGN,PUSHR,EXIT

' PRINT" HELLO WORLD"   Compile a literal print string - no length restriction - any codes can be included except the delimiter "
_PSTR_  word    _WORD,PRTSTR,COMPW
COMPSTR word    WKEY,DUP,QEMIT          ' echo string
        word    DUP,w+$22,_NEQ,_IF+02,COMPC,COMPSTR+ex
''              word align end of string with an extra null
        word    ATCODES,_1,_AND,_ZEQ,_IF+02,_0,COMPC
        word    DROP,_0
COMPC   word    ATCODES,WSTORE
''              advance code write address by 1
        word    rg+codes,LINC,COMPX+ex


' ( wordcode -- ) append this wordcode to next free code location + append EXIT (without counting)
COMPW   word    ATCODES,WALIGN,WSTORE
        word    _2,rg+codes,WPLUSST
''      word    WALIGN
''              advance code write address by 2
''      word    rg+codes,STORE
''              compile an EXIT after the latest codes
COMPX   word    w+EXIT,ATCODES,WSTOREX+ex

' C, or | ( n -- ) IMMEDIATE --- compile a byte into code and allocate
CCOMP   word    GRAB,COMPC,rg+codes,WFETCH,_1,_AND,IFEXIT,ALLOCATED+ex
' W, or || ( n -- )
WCOMP   word    GRAB,WCOMMA+ex

' , ( n -- ) Compile a long literal
LCOMP   word    GRAB
COMPL   word    DUP,COMPW,_SHR16
WCOMMA  word    COMPW,ALLOCATED+ex



' ALLOT ( bytes -- )
ALLOT   word    rg+codes,PLUSST		'',ALLOCATED+ex
' lock in compiled code so far - do not release but set new "here" to the end of these codes
ALLOCATED
        word    ATCODES,rg+here,STOREX+ex

' GRAB ( -- ) --- executes preceding code to make it available for any immediate words following
GRAB    word    w+EXIT,COMPW                                        ' append an EXIT
        word    ATHERE,DUP,rg+codes,STORE,ACALL                         ' execute and release preceding code in text line
        word    EXIT




' NFA' ( <name> -- nfaptr )
' COMPILE  ( not used in this version )
NFATICK
        word    _GETWORD,DEC,SEARCH+ex

_NFATICK
        word    NFATICK,LITCOMP+ex

' The CPA is the address of the word code stored in the header that points to the code to execute

' 03,D,U,P,CPAL,CPAH'
' CPA ( nfa -- cpa )
NFACPA	word    CFETCHINC,w+cntm,_AND,PLUS,EXIT


' ' <name>  ( -- pfa ) Find the address of the following word - zero if not found or its CFA/PFA
TICK    word    NFATICK
' CFA ( nfa -- cfa )'
NFACFA  word    DUP,ZEXIT,NFACPA
WFETCHX	word	WFETCH,EXIT

ATICK   word    TICK,LITCOMP+ex




WALIGN   word   INC,_1,_ANDN,EXIT

_ALIGNL	word	_4
' ALIGN ( address align -- val00  )                                     1- SWAP OVER + SWAP ANDN ;
_ALIGN  word    DEC,SWAP,OVERPLUS,SWAP,_ANDN,EXIT


{HELP _HERE ( -- addr ) Address of next compilation location }
ATHERE  word    rg+here,WFETCHX+ex
' ( -- atradr ) --- point to the attribute byte in the header of the latest name
ATATR
ATNAMES word    rg+names,FETCHX+ex
ATCODES word    rg+codes,WFETCHX+ex


'  CREATEWORD - create a name in the dictionary using the next word encountered in the stream
''               cnt,name,atr,cpa
CREATEWORD
        word    _GETWORD                                ' ( str ) read the next word
' CREATE$ ( str -- )
CREATESTR
        '       skip empty string '
        word    DUPCFT,SKIPNZ,DROPEX+ex
'       '       get attribute
'       word    rg+fflags,CFETCH,w+prset,_AND
'               setup CPA field right now '
        word    ATCODES,ATNAMES,DEC2,WSTORE
        '       build up a header in the word buffer then copy across
        '       get string count ( str )
        word    DEC,DUP,CFETCH,INC  ' ( c+str size )'
        '       ( str size ) update names ptr by backwards count + cpa field
        word    DUP,INC2,NEGATE,rg+names,PLUSST
        ''      copy it across
        word    ATNAMES,SWAP,CMOVE

        ''      check for dictionary full ( less than 64 bytes )
        word    ATNAMES,ATHERE
        word    w+64,PLUS,LT,ZEXIT,PRTSTR
        byte    "  Dictionary full! ",0
        word    ERROR+ex

' CREATE: <name> - Create a name in the dictionary and compile a VARIABLE code entry - or revectored through NOP
CREATE  word    _NOP,CREATEWORD,w+VARB,COMPW,_0,ALLOT+ex


' Change the value of a constant
' pub :=! ( val 'con -- )               2+ ! ;
CONST   word    INC2,STOREX+ex

_VAR    word    CREATE,SETHDR,_0,COMPL+ex

' #=
'_CON9   word    GRAB,CREATEWORD,SETHDR,BITS9,_WORD,w,PLUS,ATNAMES,NFACPA,WSTOREX+ex

' :=
_CONST  word    GRAB,CREATEWORD,SETHDR,w+CONL
DCOMP   word    COMPW,COMPL,_0,ALLOT+ex

' Identical to a constant except the call address is slightly different so a FORGET can release the data area
_DATCON word    GRAB,CREATEWORD,SETHDR
        word    w+DATCON,DCOMP+ex

PRIVATE	word	w+priatr
DEFATR	word	rg+atrs,CSTORE,EXIT
PUBLIC	word	_0,DEFATR+ex


' GETATR ( -- code )
GETATR  word  ATNAMES,_6,_SHR,EXIT

' Create a new entry in the dictionary but also prevent any execution of code
' : <name>

NEWDEF  word    CREATEWORD
REDEF   word    w+defining,SETFLG+ex                  ' flag that we have entered a definition


PUBDEF	word	_0,SDEF+ex
'MODDEF  word    w+modatr,SDEF+ex
PREDEF  word    w+preatr,SDEF+ex
PRIDEF  word    w+priatr
SDEF    word    NEWDEF
' SETATR ( code -- )
SETATR  word  	_6,_SHL,ATNAMES,CFETCH,w+cntm,_AND,_OR,ATNAMES,CSTORE,EXIT

''	merge in extra attributes
SETHDR	word	rg+atrs,CFETCH,SETATR+ex

' Update "here" pointer to point to current free position which "codes" pointer is now at
'

ENDDEF
        'word    w+EXIT,COMPW                                        ' compile an EXIT
	word	EXITS
UNDEF   word    w+defining,CLRFLG,ALLOCATED+ex              ' end definition and lock allocated bytes

'' The ; and EXIT optimizer will only compile an EXIT if it cannot modify the last call to a jump'
EXITS	word	ATCODES,DEC2,WFETCH 			' read last word compiled (could be end of a string too)'
	word	_WORD,SPACE,_WORD,$F800-1,WITHIN
	word	ATCODES,w+athen,WFETCH,_NEQ,_AND
	word	_IF+09,ATCODES,DEC2,DUP,WFETCH,_1,_OR,SWAP,WSTORE,EXIT
	word	w+EXIT,COMPW,EXIT

{

pre EXITS
	@CODES W@ 2- W@ $800 ' !SP WITHIN
	IF @CODES W@ 2- DUP W@ 1 OR SWAP W!
	ELSE ' EXIT [C] [W]
	THEN
	;
}
' [C] force compilation of the next word
COMPILES
        word    w+comp,SETFLG+ex



' ************** CASE STATEMENTS *********************8

' SWITCH ( val -- )
_SWITCH word    rg+uswitch,STOREX+ex

' SWITCH@ ( -- val )
SWFETCH word    rg+uswitch,FETCHX+ex

' SWITCH= ( val -- flg )
ISEQ
        word    SWFETCH,_EQ,EXIT

' CASE ( compare -- )
_CASE   word    _WORD,ISEQ,COMPW,_IF_+ex

' BREAK
ISEND   word    w+EXIT,COMPW,_THEN_,ALLOCATED+ex

' <CASE> '
INCASE	word	_WORD,ISWITHIN,COMPW,_IF_+ex

' SWITCH>< ( from to -- flg )..
ISWITHIN
        word    SWFETCH,ROT2,WITHIN+ex


{  Table vectoring -
index a table of vectors and jump to that vector
A table limit is supplied as well as a default vector

 Usage:
        <limit> VECTORS <vector if over>
        <vector0> <vector1> ...... <vectorx>)
Sample:
        4 LOOKUP BELL                   \ an index of 4 or more will default to BELL
        INDEX0 INDEX1 INDEX2 INDEX3     \ 0 to 3 will execute corresponding vectors

}
{
' LOOKUP
' VECTORS ( index range -- )
VECTORS
        word    OVER,GT,_ZEQ,_IF+02,DROP,MINUS1         ' limit index to range or -1 (.>0)
.L0     word    INC,_SHL1,RPOP,PLUS,WFETCH,ACALL,EXIT

}



' ( n lo hi -- flg ) true if n is within range of low and high inclusive
WITHIN  word    INC,OVER,MINUS,PUSHR
        word    MINUS,RPOP,_ULT
WT1     word    _ZNE,EXIT




{ *** MOVES & FILLS *** }
' <CMOVE ( src dst cnt -- ) byte move in reverse from the ends to the start
RCMOVE  word    ROT,OVERPLUS,DEC,ROT,THIRD,PLUS,DEC,ROT,pRCMOVE,EXIT


{ *** TIMING *** }

secs    word    W1000,MUL16
' ms ( n -- ) Wait for n milliseconds
ms      word    QDUP,ZEXIT
	word	CLKHZ,w+1000,UDIVIDE
        word    MULTIPLY,WAIT,EXIT

us      word    CLKMHZ,MUL16,w+485,MINUS,WAIT,EXIT





M       word    W1000000,MULTIPLY,EXIT
MB      word    KB
KB      word    w+10,_SHL,EXIT






{ debug print routines - also used by DUMP etc }

{HELP  .HEX ( n -- ) print nibble n as a hex character }
PRTHEX  ' ( n -- ) print n (0..$0F) as a hex character
        word    BITS4,w+"0",PLUS,DUP,w+$39,GT,_IF+02,_7,PLUS,EMIT+ex

HEXSYM  word    w+"$",EMIT+ex

PRTB    word    HEXSYM
{HELP  .BYTE ( n -- ) print n as 2 hex characters }
PRTBYTE word    DUP,_4,_SHR,PRTHEX,PRTHEX+ex

PRTW    word    HEXSYM
{HELP  .WORD ( n -- ) print n as 4 hex characters }
PRTWORD word  DUP,_SHR8
        word  PRTBYTE,PRTBYTE+ex


PRTL    word    HEXSYM
{HELP .LONG ( n -- ) print n as 8 hex characters }
PRTLONG word  DUP,_SHR16,PRTWORD
        word  SCORE,PRTWORD+ex
{
daoff	long	0
'' DUMP# ( virtual -- ) Use virtual address in dump listing rather than real address
DUMPO	word	_WORD,daoff,STORE,EXIT
}
PRTADR  word    CRLF,DUP,_SHR16,DUP
	word	_IF+03,DROP,PRTLONG,PRTCOL+ex '' xxxx_xxxx: long format
	word	PRTHEX,PRTWORD '' xxxxx: short format
PRTCOL	word	w+":",EMIT,SPACE+ex


''  *** MEMORY READ FUNCTIONS ***

DCFETCH word    rg+dmm,WFETCH,QDUP,_IF+02,ACALL,EXIT
.L0     word    CFETCH,EXIT
DWFETCH word    rg+dmm+2,WFETCH,QDUP,_IF+02,ACALL,EXIT
.L0     word    WFETCH,EXIT
DFETCH  word    rg+dmm+4,WFETCH,QDUP,_IF+02,ACALL,EXIT
.L0     word    FETCHX+ex

'' DMP: reads in memory functions to use (defaults to hubram)
SETDMP  word  RPOP,rg+dmm,_6,CMOVE,EXIT


DUMP    word    rg+dmp,WFETCH,rg+dmp,CLRW,QDUP,SKIPZ,AJMP,DUMPB+ex

DMPA	word	IX,PRTADR,IX,_16,rg+dcnt,CLRC,EXIT
DSPACE	word	SPACE,rg+dcnt,CINC,rg+dcnt,CFETCH,_3,_AND,IFEXIT,SPACE+ex
{ QUICK DUMP }
QD      word    w+$20
'' DUMP ( addr cnt -- ) Hex dump of hub RAM - }
DUMPB   word    ADO
        word      DMPA,ADO,IX,DCFETCH,PRTBYTE,DSPACE,LOOP
DMPASC  word      DUMPASC
        word    _16,PLOOP
RAM     word    rg+dmm,_8,ERASE,EXIT

' QUICK WORD DUMP '
QW	word	w+$20
{ DUMP as WORDs }
DUMPW   word    ADO
        word      DMPA,ADO,IX,DWFETCH,PRTWORD,DSPACE,_2,PLOOP
	word 	  DMPASC+ex

{ DUMP as LONGs }
DUMPL   word    ADO
        word      DMPA,ADO,IX,DFETCH,PRTLONG,DSPACE,_4,PLOOP
	word 	  DMPASC+ex

{ DUMP as ASCII WIDE }
DUMPAW  word    w+128,DUMPS+ex
{ DUMP as ASCII }
DUMPA   word    w+64
DUMPS   word    ROT2
        word    ADO
        word      IX,PRTADR
        word      IX,OVER,ATYPE
        word    DUP,PLOOP,DROP
        word    RAM+ex
ATYPE	word	ADO,IX,DCFETCH,AEMIT,LOOP,EXIT


DUMPASC word      SPACES3,PRTTICK,IX,_16,ADO,IX,DCFETCH,AEMIT,LOOP,PRTTICK+ex


_LUT    word    w+LUTFETCH,COGSET+ex
_COG    word    w+COGFETCH
COGSET  word    _WORD,COGLUT,WSTORE,_WORD,COGDUMP,rg+dmp,WSTOREX+ex

COGDUMP
        word    ADO,IX,_7,_AND,_ZEQ,_IF+09,CRLF,SPACE,SPACE,IX,_SHR8,PRTHEX,IX,PRTBYTE,PRTCOL
''        word    IX,_3,_AND,SKIPNZ,SPACE
	word	IX
COGLUT  word    COGFETCH,PRTLONG,DSPACE,LOOP,EXIT



' Print the stack(s) and dump the registers - also called by hitting <ctrl>D during text input
DEBUG	word	rg+linenum,CLRW
   	word    PRTSTKS
        word    PRTSTR
        byte    $0D,$0A,"COG  ",0
        word    _0,w+$28,COGDUMP
        word    PRTSTR
        byte    $0D,$0A,"REGS ",0
        word    rg+temp,w+$100,DUMPW
        word    PRTSTR
        byte    $0D,$0A,"CODE ",0
        word    ATHERE,_32,MINUS,w+64,DUMPW
        word    PRTSTR
        byte    $0D,$0A,"WORDS",0
        word    ATNAMES,w+$40,DUMPB
        word    CRLF,lsio
        word    CRLF+ex

{
PRTP	word    PRTSTRN
        byte    $0D,"P:",0
	word	EXIT
}
lsio	word	w+"P",PRTHD,w+64,_0,DO,IX,w+10,DIVIDE,PRINT,LOOP
        word    w+"P",PRTHD,w+64,_0,DO,IX,w+10,UMOD,PRINT,LOOP
	' SAVE DIR & OUT STATES '
	word	w+OUTA,COGFETCH,w+OUTB,COGFETCH
	word	w+DIRA,COGFETCH,w+DIRB,COGFETCH
	' DISPLAY I/O STATE as l=low input, h=high input, L=low output, H=high output'
	word	w+"?",PRTHD,w+64,_0,DO
	word	IX,PINTEST,_AND1
	word	IX,MASK,w+DIRA,IX,_5,_SHR,PLUS,COGFETCH,_AND,_IF+01,INC2
	word	_WORD,lhstr,PLUS,CFETCH,EMIT,LOOP
	' FLOAT TEST '
	word	w+"=",PRTHD,w+62,_0,DO
        word    IX,LOW,w+200,WAIT,IX,_FLOAT,w+200,WAIT,IX,PINTEST,_AND1,_SHL1
        word    IX,HIGH,w+200,WAIT,IX,_FLOAT,w+200,WAIT,IX,PINTEST,_AND1,_OR
        word    _WORD,dustr,PLUS,CFETCH,EMIT,LOOP
	word	w+DIRB,COGSTORE,w+DIRA,COGSTORE
	word	w+OUTB,COGSTORE,w+OUTA,COGSTORE
        word    EXIT

dustr	byte    "d~?u"
lhstr	byte	"lhLH"
{
PRTHD   word    PRTSTRN
        byte    $0D,"=:",0
	word	EXIT
}
PRTHD	word	CRLF,EMIT,w+":",EMIT,EXIT


ELAPSED
LAPCAL  word    LAPFETCH,LAP,LAP,LAPFETCH,MINUS,EXIT
{
: .CLK
	CLKHZ 1 M // 0=
 	IF CLKHZ 1 M U/ . ." MHz" ELSE CLKHZ .DECL ." Hz" THEN
 ;

: .LAP
	LAP@ LAP LAP LAP@ -
	( cycles/clkhz )
	DUP .DECL ."  cycles = "
	1,000,000 CLKHZ 1000 U/ */  ( scale cycles to nanoseconds )
	.DECL ." ns @" .CLK
	;
}
MILLION	word	CONL
	long	1000000

PRTCLK	word	CLKHZ,DUP,MILLION,UMOD,_IF+05
	word	PRTDECL,PRTSTR
	byte	"Hz ",0
	word	EXIT
	word	MILLION,UDIVIDE,PRINT,PRTSTR
	byte	"MHz",0
	word	EXIT

PRTMS
PRTLAP  word    LAPCAL
PRTCYC  word    DUP,PRTDECL,PRTSTR
        byte    " cycles= ",0
	word	MILLION,CLKHZ,w+1000,UDIVIDE,MULDIV,PRTDECL,PRTSTR
	byte	"ns @",0,0
	word	PRTCLK+ex
{
REPLAP  word    DUP,CLKHZ,LT,_IF+17,w+100,MULTIPLY,_3,_SHR,.L0+ex
        ''      CLKHZ U// PRINT DOT #1000 CLKHZ */ PRINT ." sec" EXIT THEN
        word    CLKHZ,UDIVMOD,PRINT,DOT,W1000,CLKHZ,MULDIV,PRINT,PRTSTR
        byte    "sec",0
        word    EXIT
        ''      DUP #999999 > IF #1,000,000 U// PRINT DOT  #1000 U/ PRINT ." ms " EXIT THEN
.L0     word    DUP,W1000000,EQGT,_IF+11,W1000000,UDIVMOD,PRINT,DOT,W1000,UDIVIDE,PRINT,PRTSTR
        byte    "ms ",0
        word    EXIT
        '       DUP #999 > IF #1,000 U// PRINT DOT PRINT ." us" EXIT THEN
.L1     word    DUP,W1000,EQGT,_IF+09,W1000,UDIVMOD,PRINT,DOT,PRINT,PRTSTR
        byte    "us ",0
        word    EXIT
        '       PRINT ." ns "
.L2     word    PRINT,PRTSTR
        byte    "ns ",0
        word    EXIT
' .ms           LAP@ LAP LAP LAP@ - ~l ;
PRTMS   word    LAPCAL,REPLAP+ex
}

QSTACKS
	word	_DEPTH,w+32,GT,ZEXIT,INITSP,EXIT

PRTSTK  word    PRTSTRN
        byte    " DATA STACK (",0
        word    _DEPTH,DUP,PRINT1
        word    ZEXIT
        word    _DEPTH,w+32,_MIN,DUP,_0
        word    DO,CRLF,IX,INC,PRINT,SPACES3,DEC,DUP,INC4,LUTFETCH,DUP,PRTL,SPACES3,PRINT,LOOP
        word    DROPEX+ex
PRINT1  word    PRINT,w+")",EMIT+ex

PRTSTKS word    PRTSTK
PRTRET  word    PRTSTRN
        byte    " RETURN (",0
        word    w+retstk,w+retptr
PRTSTKX word    COGFETCH,DUP2,SWAP,MINUS,PRINT1
DMPSTK  word    SPACES3,SWAP
.L0     word    DUP2,_NEQ,_IF+06,DUP,LUTFETCH,SPACE,PRTL,INC,.L0+ex,DROP2,EXIT


QCHAR   word    DUP,_BL,w+$7E,WITHIN+ex
TOCHAR  word    QCHAR,_ZEQ,_IF+02,DROP,w+$20,EXIT

' @PAD ( -- addr ) pointer to current position in number pad
ATPAD   word    rg+padwr,CFETCH,rg+numpad,PLUS,EXIT

' >CHAR  ( val -- ch ) convert binary value to an ASCII character
BINASC  word    w+$3F,_AND,w+"0",PLUS,DUP,w+"9"                 ' convert to "0".."9"
        word    GT,_7,_AND,PLUS                                         ' convert to "A"..
        word    DUP,w+$5D,GT,ZEXIT,_3,PLUS,EXIT                 ' skip symbols to go to "a"..

' <#    ' resets number pad write index to end of pad
LHASH   word    w+numpadsz,rg+padwr,CSTORE,_0
'''
' HOLD ( char -- )
HOLD    word    rg+padwr,CDEC,ATPAD,CSTOREX+ex


' # ( n1 -- n2 ) convert the next ls digit of a double to a char and prepend to number string
HASH    word    rg+double,FETCH,GETBASE,UMDIVMOD64,rg+double,STORE
        word    SWAP,BINASC,HOLD+ex
        ' conversion digits exhausted, use zeros or spaces

' #S ( d1 -- 0 ) Convert all digits
HASHS   word    HASH,DUP,_ZEQ,_UNTIL+04,EXIT

' #> ( n1 -- caddr )
RHASH   word    DROP,ATPAD,rg+double,CLRL,EXIT

' <D> ( d1 -- n1 ) ' Store high long of double for formating
DNUM    word    rg+double
STOREX	word	STORE,EXIT


' . ( n -- ) Print the number off the stack
PRINT
PRT     word    DUP,_ZLT,_IF+03,w+"-",EMIT,NEGATE
'''
' U. ( n -- ) Print an unsigned number
UPRT    word    LHASH,HASHS,RHASH
'''


' PRINT$ ( adr -- ) Print the null or 8th bit terminated string - stops on any non-printable character
PRINTSTR
	word	DUP,INC,SWAP,DCFETCH,QDUP,_IF+02,EMIT,PRINTSTR+ex
pstrxt  word    DROP,RAM+ex


' since printing a 32-bit binary number with formatting can be quite long, this one prints directly
PRTBIN  word    w+"%",EMIT,_BL,FOR,DUP,w+31,_SHR,w+"0",PLUS,EMIT,_SHL1,forNEXT,DROPEX+ex





{
	.AS" Format string spec:
	#       Convert one digit (default is decimal)
	~       Toggle leading zero suppression
	\       pad leading zeros with spaces
	$|      Hexadecimal
	*|      Convert all remaining digits
	4|      Convert 4 digits

	PFLG

|	4
\	2
~	1	Suppress leading zeros

TAQOZ# 12 .AS" 5|" 00012 ok
TAQOZ# 12 .AS" 5|\"     12 ok
}
' DZEQ    word    DUP2,_OR,_ZEQ,EXIT

' process a single .AS char  ( numl numh char )
ASCHAR  word    _SWITCH,_4,rg+pflg,BITQ,_NOT,_4,rg+pflg,CLR,_IF+(ASCMD-.L3)/2
.L3     word    w+"|",ISEQ,_IF+04,_4
SETP	word	rg+pflg,SET,EXIT
        word    w+"~",ISEQ,_IF+02,_1,SETP+ex
        word    w+"\",ISEQ,_IF+02,_2,SETP+ex
	''	suppress leading zeros?'
        word    DZEQ,_1,rg+pflg,BITQ,_AND,IFEXIT
	''	Convert a digit?'
        word    w+"#",ISEQ,_IF+(ASONE-.L0)/2
.L0	''      null?  spaces?  ( numl numh ) '
AHASH   word    DZEQ,_2,rg+pflg,BITQ,_AND,_IF+02,w+$20,HOLD+ex
	''	extract lsd from double and convert and insert as ASCII
	word	rg+pbase,CFETCH,UMDIVMOD64,ROT,BINASC,HOLD+ex

        ''      $| command - hexadecimal
ASCMD   word    w+"$",ISEQ,_IF+03,_16,rg+pbase,CSTOREX+ex
        ''      n| multiple # command 3 TO 9
        word    SWFETCH,w+"3",w+"9",WITHIN,_IF+07,SWFETCH,w+"0",MINUS,FOR,AHASH,forNEXT,EXIT
        ''      *| Convert remaining digits
.L2     word    w+"*",ISEQ,_IF+05,DUP2,_OR,ZEXIT,AHASH,.L2+ex
        ''      [| send an escape
        word    w+"[",ISEQ,_IF+02,w+$1B,AHOLD+ex
        ''      @| treat simply as ASCII
        word    w+"@",ISEQ,_IF+03,OVER,BITS8,AHOLD+ex
        ''      literal character
ASONE   word    SWFETCH,HOLD+ex

AHOLD   word    TOCHAR,HOLD+ex
{
pub .AS ( num format -- )
	12 REG @ SWAP  pflg C~ 10 pbase C!
	<# DUP LEN$ 1- OVER+ FROM -1 BY LEN$
	  FOR I C@ AS# NEXT  DROP
	#> PRINT$
	;
}
	''	find end of string and push next instruction onto return'
PRTAST  word    RPOP,DUP,STRLEN,INC2,_1,_ANDN,OVERPLUS,PUSHR

	'word	DROP,PRT+ex

	'' ( num fmtstr )	clear format and select decimal'
PRTAS   word    rg+pflg,CLRC,w+10,rg+pbase,CSTORE
	''	( numl fmtstr )'
'word    rg+double,FETCH,SWAP
	''  start conversion and point to end of fmtend to start from there back'
	'' 					( numl fmtstr fmtend )'
	word	LHASH,DUP,STRLEN,DEC,OVERPLUS
	'' ( fmtend numl numh fmtstr )'
	word	ROT2,rg+double,FETCH,SWAP
	''	step through ( fmtend numl numh ) '
        word    STRLEN,FOR,THIRD,CFETCH,ASCHAR,ROT,DEC,ROT2,forNEXT
        word    DROP2,RHASH,PRINTSTR+ex

PRTASR  word    _WORD,PRTAST,COMPW,COMPSTR+ex

PRTDECL word    PRTAST
        byte    "##,###,###,##~#",0
        word    EXIT

PRTDEC4 word    PRTAST
        byte    "###\#",0
        word    EXIT

PRTDEC2 word    PRTAST
        byte    ".##",0
        word    EXIT
{
PRTDEC2D
        word    PRTAST
        byte    "##.",0
        word    EXIT
}
' Print decimal with at least a single digit
PRTDEC  word    PRTAST
        byte    "*|#",0
        word    EXIT


{ *** NUMBER BASE *** }


' change the default number bases

BIN     word    w+2
SETBASE word    rg+base
CSTOREX word    CSTORE,EXIT
DECIMAL word    w+10,SETBASE+ex
HEX     word    w+16,SETBASE+ex
GETBASE word    rg+BASE,CFETCH,EXIT


' >UPPER  ( str1 --  ) Convert lower-case letters to upper-case
TULP    word    INC
TOUPPER word    DUPCFT,QDUP,_IF+08                      ' end of string?
        word    w+"a",w+"z",WITHIN
        word    _UNTIL+08
        word    w+$E0,OVER,CPLUSST,TULP+ex              ' convert case (subtract $20)
        word    DROPEX+ex

{ *** STRING TO NUMBER CONVERSION *** }

' DECIMAL? '
DECQ    word    w+"0",w+"9",WITHIN+ex
' HEX? '
HEXQ    word    w+"A",w+"F",WITHIN+ex

' functional test for now - optimize later
' Convert ASCII value as a digit to a numeric value - only interested in bases up to 16 at present
'
TODIGIT ' ( char -- val true | false )
        word    DUP,DECQ,_IF+04 ',td8           ' only work with 0..9,A..F
        word    w+"0",MINUS
TRUEX   word    _TRUE,EXIT                      ' pass decimal digits
td8     word    DUP,HEXQ,_IF+03 ',td2
        word    w+$37,MINUS,TRUEX+ex            ' pass hex digits
td2     word    DROP
FALX    word    _FALSE,EXIT

{  Try to convert a string to a number
Allow all kinds of symbols but these are the rules for it to be treated as a number.
1. Leading character must be either a recognized prefix or a decimal digit
2. If trailing character is a recognized suffix then the first character must be a decimal digit
Acceptable forms are:
$1000   hex number
1000h
#1000   decimal number
1000d
%1000   binary number
1000b

Also as long as the first character and last character are valid (0..9,prefix,suffix) then any symbols me be mixed in the number i.e.
11:59  11.59  #5_000_000

$FFFFFFFF
4294967295

DOUBLE NUMBERS - use a dot at end of number to signify double-precision (or >32bits)
$DEADBEEFBABECAFE.
18446744073709551615d.
}

OVEQ	word	THIRD,_EQ,EXIT

' ': DM* ( d. n -- d. )	-ROT SWAP 3RD UM* ROT 4TH * + ROT DROP ;
DMMUL	word	ROT2,SWAP,THIRD,UMMUL,ROT,FOURTH,MULTIPLY,PLUS,ROT,DROP,EXIT
FETCH2	word	DUP,FETCH,SWAP,INC4,FETCH,EXIT
STORE2	word	SWAP,OVER,INC4,STORE,STORE,EXIT

DNUMQ	word	rg+suffix,CFETCH,w+".",_EQ,EXIT

_NUMBER ' ( str -- value digits | false )
        word    rg+4,CLRL                                               ' REG0L = 0
        word    w+sign,CLRflg						' clear sign
snlp
        word    DUP,STRLEN,OVERPLUS,DEC,CFETCH,rg+suffix,CSTORE		' save suffix (assume string has count byte)
        word    DUPCFT,w+"-",_EQ,_IF+03                                 ' save SIGN
        word    w+sign,SETFLG,INC					' and use string without sign
                                                                        ' prefix may come after the sign
        word    DUPCFT,DUP,rg+prefix,CSTORE                             ' save prefix (it may or may not be)

        ' PREFIX HANDLER
        '       ( str ch )
        word    _FALSE                                                  ' preset prefix flag = false
        word    w+"$",OVEQ,_IF+02,HEX,INC				' $nnnn - set hex base - flag true
        word    w+"#",OVEQ,_IF+02,DECIMAL,INC				' as does # - also set decimal base
        word    w+"%",OVEQ,_IF+02,BIN,INC 				' as does % - also set binary base
        word    w+"&",OVEQ,_IF+05,DECIMAL,INC				' as does & - also set decimal base and IP notation
        word    w+$80,rg+bnumber+3,CSTORE                               ' this forces "." symbols to work the same as ":"
        '       ( str ch flg )
        word    DUP,_IF+03,ROT,INC,ROT2                                 ' adjust string pointer to skip prefix
        '       ( str ch flg )
        word    SWAP,DECQ,_OR                                           ' 0..9 forces processing as a number
        ''      ( str flg ) flg is true if a prefix is found OR the first character is 0..9
        word    SKIPNZ,DROPFEX+ex ' ( -- false )   			' Give up now, it isn't a candiate
        ''      ( str )                                                 ' so far, so good, now check suffix
        '' SUFFIX HANDLER  - must end in 0..9 or A..F or valid suffix
        word    rg+suffix,CFETCH
        word    DUP,DECQ                                                ' 0..9
        word    OVER,HEXQ,_OR                                           ' A..F ( str sfx flg ) true if still a digit
	word	OVER,w+".",_EQ,_OR					' allow decimal point suffix (double) 190124'
        word    w+"h",OVEQ,_IF+02,HEX,INC                           	' h = HEX
        word    w+"b",OVEQ,_IF+02,BIN,INC                           	' b = BINARY
        word    SWAP,w+"d",_EQ,_IF+02,DECIMAL,INC                       ' d = DECIMAL
        word    SKIPNZ,DROPFEX+ex                                   	' bad suffix, no good
        '' so far the prefix and suffx have been checked prior to attempt a number conversion
        '' From here on there must be at least one valid digit for a number to be accepted
	''
        '' *** DIGIT EXTRACTION & ACCUMULATION ***
nmlp
        word    DUPCFT,DUP,_IF+(nmend-nm1)/2				' while there is another character
nm1     word    TODIGIT,_IF+(nmsym-nm2)/2                               ' convert to a digit? or else check symbol
        '' a digit has been found but is it valid for this base? 	' ( str val )
nm2     word    DUP,GETBASE,DEC,GT,_IF+02
FALX2   word    DROP2,FALX+ex						' a digit but exceeded base

'nmok    word    rg+anumber,FETCH,GETBASE,MULTIPLY			' shift anumber left one digit (base)
''        word    PLUS,rg+anumber,STORE					' and merge in new digit
	''	shift double number up one digit and merge
nmok    word    rg+anumber,FETCH2,GETBASE,DMMUL				' shift anumber left one digit (base)
        word    ROT2,PLUS,SWAP,rg+anumber,STORE2			' and merge in new digit

        word    rg+digits,CINC						' update number of digits
nmnxt   word    INC,nmlp+ex						' update str and loop

        '' character was not a digit - check for valid symbols (keep it simple for now)
        '' SYMBOLS
nmsym   word    DUPCFT,w+":",_EQ                                        ' : ENTER
        word    OVER,CFETCH,w+".",_EQ                                   '  . dot
        word    DUP,_IF+04,rg+digits,CFETCH,rg+dpl,CSTORE               ' remember last decimal place
ns01    word    rg+bnumber,FETCH,_ZNE,_AND,_OR
        word    _IF+10                                                  ' Use : as special byte shift for IP notation etc
nmsym1  word    rg+bnumber,FETCH
        word    rg+anumber,FETCH,PLUS,_SHL8
        word    rg+bnumber,STORE,rg+anumber,CLRL                        ' accumulate & number in bnumber
nmsym2  word    nmnxt+ex                                                ' just ignore other symbols for now
        '
nmend   ' end of string - check and push number onto stack
        word    DROP2,rg+digits,CFETCH,DUP,ZEXIT                        ' return with false if there are no digits
        word    rg+anumber,FETCH,rg+bnumber,FETCH,PLUS
        word    w+sign,CHKFLG,QNEGATE
'!!!! need to be able to negate double number !!!!'
	word 	DNUMQ,_IF+04,rg+hnumber,FETCH,ROT,EXIT
        word    SWAP,EXIT                                               ' all good, return with number and true

' NUMBER processing -try to convert a string to a number
NUMBER  ' ( str -- value digits | false )
        ' process control prefix i.e. ^A
        word    DUP,STRLEN,_2,_EQ
        word    OVER,CFETCH,w+"^",_EQ,_AND,_IF+06                       ' ^ch  Accept caret char as <control> char
        word    INC,CFETCH,w+$1F,_AND,_1,EXIT                           ' control character processed - single digit
        '' process character literal i.e. "A"
ch01    word    DUP,STRLEN,_3,_EQ
        word    OVER,CFETCH,DUP,w+$22,_EQ,SWAP,w+$27,_EQ
        word    _OR,_AND,_IF+04                                 	' "ch" or 'ch' Accept as an ASCII literal
ascch   word    INC,CFETCH,_1,EXIT

                                                                        ' It wasn't an ASCII literal, process as a number
ch02    word    rg+anumber,w+(dpl-anumber+1),ERASE                      ' zero out assembled number (double), digits, dpl
        word    GETBASE,rg+base+1,CSTORE                                ' backup current base as it may be overridden
        word    _NUMBER '( str -- digits num | false )
nmb1    word    rg+base+1,CFETCH,SETBASE+ex                             ' restore default base before returning



' QFNUM ( -- flg ) Test if word is a fast prefixed number
QFNUM   'word   _TRUE,rg+wordbuf,DUP,STRLEN,ADO,IX,CFETCH,DECQ,_AND,LOOP,QDUP,IFEXIT
        word    rg+wordbuf,CFETCH,w+"#",w+"%",WITHIN                    ' Numeric prefixes?
        word    rg+wordbuf-1,CFETCH,_2,GT,_AND                          ' and more than 2 characters? (inc term)
        word    rg+wordbuf-1,DUPCFT,PLUS,CFETCH                 ' and last char is a digit or hex digit?
        word    DUP,DECQ                                                ' decimal digit?
        word    SWAP,HEXQ,_OR,_AND                                      ' hex digit?
        word    EXIT



{ *** COMPILER EXTENSIONS *** }



' Most of these words are acted upon immediately rather than compiled as they are
' part of the "compiler" in that they create the necessary structures
'

''' dumb compiler for literals - improve later - just needs to optimize the number of bytes needed
LITCOMP ' ( n -- ) compile the literal according to size
        word    DUP,_SHR16,_IF+07
        	' Compile long
        word    w+_LONG,COMPW                               ' compile the _LONG instruction
        word    DUP,_SHR16,SWAP,COMPW,COMPW+ex                                  ' compile the long itself
        	' Compile 2 bytes - 16bits
.L1     word    DUP,W+10,_SHR,_IF+03			' 10 BIT LITERAL?'
        word	w+_WORD,COMPW,COMPW+ex
.L2     	' Compile short literal directly
        word    _WORD,w,PLUS,COMPW+ex

'---------------------------------------------------



{ *** CONSOLE INPUT HANDLERS *** }

{
Replaced traditional parse function with realtime stream parsing
Each word is acted upon when a delimiter is encountered and this also allows for
interactive error checking and even autocompletion.
}

' SCRUB --- scrub out any temporary compiled code, restore the code pointers etc.
SCRUB   word    ATHERE,rg+codes,STORE
        word    rg+wordcnt,CLRC,rg+wordbuf,CLRC
''      restore end-of-line delimiter to a CR
        word    _13,rg+delim+1,CSTORE
''      print long line of dashes
PRTDASH word    CR,w+"-",w+79,EMITS+ex

' 	PUTCH ( ch -- ) write a character into the next free position in the word buffer
PUTCHAR word    rg+wordcnt,CFETCHINC,PLUS,CSTOREX+ex

PUTCHARPL
        word    PUTCHAR,rg+wordcnt,DUPCFT,INC
        word    w+wordsz,UMOD,SWAP,CSTOREX+ex

HEXASC	word	BITS4,w+$30,PLUS,DUP,w+$39,GT,w+7,_AND,PLUS,EXIT

' Function keys execute immediately and search dictionary for matching :xx where xx = hex code'
' Define function for F12 ->  pub :FC  <my function> ;
FNCKEY	word	w+":",PUTCHARPL
	word	DUP,_4,_SHR,HEXASC,PUTCHARPL
	word	HEXASC,PUTCHARPL,w+$0D,DCH1+ex

' 	As characters are accepted from the input stream, checks need to be made for delimiters,
doCHAR  ' ( char -- flg ) Process char into wordbuf and flag true if all done
' 	editing commands etc. 123us/CHAR, 184us/CTRL
'       ignore null
        word    DUP,ZEXIT
'       delimiter is always last character
DCH1    word    DUP,rg+delim+1,CSTORE
'       Replace DEL with BS
        word    w+$7F,OVER,_EQ,_IF+02,DROP,_8

' 	check for 8-bit special characters '
	word	DUP,w+$80,_AND,_IF+01,FNCKEY+ex
'       only check for control characters
	word    DUP,_BL,LT,_IF+(ischar-ctrls)/2
'
' PROCESS CONTROL CHARACTERS
'
ctrls
''              discard LF
        word    w+$0A,OVER,_EQ,SKIPZ,DROPFEX+ex
''              ^W WORDS
        word    w+$17,OVER,_EQ,_IF+04,DROP,QWORDS,CRLF,FALX+ex
''              ^R FIXDICT
''      word    w+$12,OVER,_EQ,_IF+03,DROP,FIXDICT,FALX+ex

'               ^X reeXecute previous compiled line
        word    w+$18,OVER,_EQ,_IF+02,DROP,TRUEX+ex
''              ^C RESET
        word    _3,OVER,_EQ,SKIPZ,RESET
'               ^R RESTORE
        word    w+$12,OVER,_EQ,_IF+03,DROP,RESTORE,TERMINAL
''              ^V VERSION
        word    w+$16,OVER,_EQ,_IF+02,PRTVER,CONSOLE+ex
'               ^D DEBUGGER
        word    _4,OVER,_EQ,_IF+03,DROP,DEBUGGER,FALX+ex
'               ^? DEBUG
        word    w+$1F,OVER,_EQ,_IF+03,DROP,DEBUG,FALX+ex

'               ^Q print top stack
        word    w+$11,OVER,_EQ,_IF+04,DROP,PRTSTK,CRLF,FALX+ex
'               ^S clear Stack
        word    w+$13,OVER,_EQ,_IF+03,DROP,INITSP,FALX+ex
'               ^B Block dump
        word    _2,OVER,_EQ,_IF+06,DROP
        word    _0,w+$100,_SHL8
        word    DUMPB,FALX+ex
'               ^K  --- ^Z^Z cold start
        word    w+$0B,OVER,_EQ          '''rg,prevch+1,CFETCH,w+$1A,_EQ,_AND
        word    _IF+03,DROP,COLDST,RESET        '''SCRUB,FALX+ex
ignore2
        word    w+$1B,OVER,_EQ,_IF+03,DROP,SCRUB,TRUEX+ex                               ' ESC will cancel line
ig01    word    _9,OVER,_EQ,_IF+02,EMIT,_BL                                             ' TAB - substitute with a space
ig02    word    w+$1C,OVER,_EQ,_IF+03,DROP,CRLF,_BL                                     ' ^| - multi-line interactive
ig03    word    _13,OVER,_EQ,_IF+02,DROP,TRUEX+ex                                       ' CR - Return & indicate completion
ig04    '
        word    _8,OVER,_EQ,_IF+(ischar-bksp1)/2                                        ' BKSP - null out last char
bksp1   word    rg+wordcnt,CFETCH,_IF+09                                                ' don't backspace on empty word
bksp2   word    EMIT,SPACE,_8,EMIT                                                      ' backspace and clear
        word    rg+wordcnt,CDEC,_0,PUTCHAR                                              ' null previous char
        word    FALX+ex
        ''                      '
bksp3   word    _7,EMIT,DROPFEX+ex                                                      ' can't backspace anymore, bell

	' PROCESS CHARACTER
ischar  word    w+echo,CHKFLG,_IF+02,DUP,EMIT                                           ' don't echo if we don't want it
.L0     word    rg+delim,CFETCH,OVER,_EQ                                                ' delimiter? (always accept a blank)
        word    OVER,_BL,_EQ,_OR,_IF+04,DROP,rg+wordcnt,CFETCH,EXIT                     ' true if trailing delimiter - all done (flg=cnt)
        '
        ' otherwise build text in wordbuf - null terminated with a preceding count .....
.L1     word    PUTCHARPL,FALX+ex                                                       ' put a character into the word buffer

' Build a delimited word in wordbuf for wordcnt and return immediately upon a valid delimiter
_GETWORD        ' ( -- str )
'       Erase the word buffer & preceding count
        word    rg+wordcnt,w+wordsz,ERASE
'       get another character
        word    WKEY,doCHAR,_UNTIL+03
        word    rg+wordbuf,EXIT


{ ****************** DICTIONARY SEARCH ********************** }

' SEARCH ( cstr -- nfaptr )                                             ' cstr points to the count+strinw+null
SEARCH
        word    rg+ufind,QJMP                                           ' use alternative method if enabled (hash search)
        word    DUP,ATNAMES,FINDSTR
        word    QDUP,_IF+02,NIP,EXIT                                    ' found it - return now with result
DROPFEX word    DROP,FALX+ex                                            ' not found in dictionary





' Discard the current line
DISCARD
dslp    word    KEY,_ZEQ,_UNTIL+03                                              ' fast discard
ds01    word    w+20,ms,KEY,_ZEQ,_UNTIL+08,EXIT                                ' pause and check and repeat if necessarys

ATID    word    _COGID
' TASK ( cog -- addr ) Return with address of task control register in "tasks"
TASK    word    _3,_SHL,_WORD,tasks,PLUS,EXIT

{ TASK RECORD
0       ENTRY CODE ADDRESS
4       flags

}

IDLE    word    INITSTKS
        word    ATID,_8,ERASE					' clear this cog's task registers
idlp    word    _1,ATID,_3,PLUS,CPLUSST                         ' increment task+3 to indicate Tachyon running
        'word    w+10,ms                                         ' do nothing for a bit - saves power (but not with P2)
        word    ATID,WFETCH                                     ' fetch cog's task variable
        word    QDUP,_UNTIL+09                                  ' until it is non-zero
        word    ACALL                                           ' Execute
        word    ATID,CLRW                                       ' clear run address only if it has returned back to idle
        word    IDLE+ex


AUTORUN word    TICK,rg+autovec,WSTOREX+ex

radix   byte    "01%34567o9#BCDEF$ "

        ''      List line number if enabled
PROMPT
        ''      execute user prompt code
        word    rg+uprompt,WFETCH,QDUP,_IF+02,ACALL,trl1+ex
        word    rg+linenum,WFETCH,_IF+08
        ''      display line#
        word    CR,rg+linenum,WFETCH,PRTDEC4,SPACES3
        ''      increment line#
        word    rg+linenum,WINC,EXIT
        ''      Prompt with version and base
        word    PRTSTR
        byte    "TAQOZ",0
        ''      prompt char = base %#$ etc
        word    GETBASE,_WORD,radix,PLUS,CFETCH,EMIT,SPACE+ex



' COLD  Force factory defaults
COLDST
{
FIXDICT         ' Copy dictionary from ROM to area just before copied ROM in bank 0'
        word    _LONG
        long    romdict
        word    _LONG
        long    ramdict
        word    _WORD,enddict-romdict,CMOVE
}
''              initialize task registers
''              free memory                   backup
	word	rg+0,w+$100,ERASE			' init task registers'
        word    _WORD,codeorg				' init code pointers'
        word    DUP,rg+here,STORE,rg+here-4,STORE
	word	datcold,DATORG				' init data pointer'
        word    wordcold,rg+names,STORE			' init dictionary pointer'
'               reset cold start
XCOLD  	word    _CON,PRTSTR
        byte    "x",$0D,$0A,"  Cold start",0
   	word    _WORD,$A55A,rg+cold,WSTOREX+ex

wordcold
	word	CONL
	long	ramdict
datcold	word	CONL
	long	datram

{ *** MAIN TERMINAL CONSOLE ***  }
TERMINAL
        word    InitRP,INITSP                                           	' Init the internal stack and setup external stack space
        word    WP,w+50,ms                                                      ' a little startup delay (also wait for serial cog)
	''      performing a check for a saved session
        word    rg+cold,WFETCH,_WORD,$A55A,_NEQ,SKIPZ,COLDST
        word    _CON
        word    rg+keypoll,CLRW,rg+uaccept,CLRW
        word    rg+linenum,CLRW
        word    _1,rg+fflags,WSTORE
        ''      Show VERSION with optional CLS (default CR)
        word    CRLF,PRTDASH,CRLF,DECIMAL,PRTVER
''      word    _GETRND,rg+bootsig,STORE

        ''      ^A abort autostart with ^A
        word    w+@lastkey,CFETCH,_1,_NEQ,_IF+(CS1-.L0)/2
        ''      check for an AUTORUN
        word    rg+autovec,WFETCH,QDUP,SKIPZ,ACALL
        ''      Set the rx buffer size
.L0     ''      echo on
        word    w+echo,rg+fflags,CSTORE
        ''      default delimiter is a space character
        word    _BL,rg+delim,CSTORE

        '
CONSOLE word    InitRP,SCRUB,CRLF
        ''      Stop compilation
CS1     word    w+defining,CLRFLG
        '
        ' ***   Main console line loop - get a new line (word by word) ***
        '

LINELP  word    PROMPT
        ''      reset temporary code compilation pointer
trl1    word    ATHERE,rg+codes,STORE
        '
        ''      Main console loop - read a word and process
WORDLP	word	QSTACKS
  	word    _GETWORD
        word    _4,rg+fflags+1,CLR
        ''      ignore empty string
        word    CFETCH,_ZEQ,_IF+(EVAL-.L0)/2
        ''      ^X then repeat last line
.L0     word    rg+delim+1,CFETCH,w+$18,_NEQ,_IF+(execinp-.L2)/2
        ''      Otherwise process ENTER
.L2     word    rg+delim+1,CFETCH,_13,_NEQ,_IF+(chkeol-EVAL)/2
        ''      good, try to process this as a number first (for speed)
EVAL    word    QFNUM,_ZEQ,_IF+(TRYNUM-trm4)/2
        ''      otherwise search the dicitonary for a match (as a counted string)
trm4    word    rg+wordbuf,DEC,SEARCH
        ''      found it
        word    QDUP,_IF+(TRYNUM-foundword)/2
        ''      found the word in the dictionary - compile or execute?
foundword
'               point to attribute word (CNT,<NAME>,ATR,CPA)
        word    DUP,NFACFA  ' ( cpa cfa )
        ''      is the immediate bit set?
        word    SWAP,CFETCH,_6,_SHR,w+preatr,_EQ
        ''      and comp flag off (not forced to compile with [COMPILE])
        word    w+comp,CHKFLG,_ZEQ,_AND
        ''              Fetch and EXECUTE code immediately
        word    _IF+02,ACALL,chkeol+ex

compword
        ''      or else COMPILE the wordcode(s) for this word
        word    COMPW
        ''      reset any forced compile mode via [COMPILE]
        word    w+comp,CLRFLG
        ''      *** END OF LINE CHECK ***
chkeol  word    rg+delim+1,CFETCH,_13,_EQ
        word    DUP,_IF+(eol01-.L0)/2
        ''      Yes, put a space between any user input and response
.L0     word    rg+uaccept,WFETCH,QDUP,_IF+02,ACALL,eol01+ex
	word	PRTSTR
	byte	" --- ",0
        ''      and are we in a definition or interactive?
eol01   word    DUP,w+defining,CHKFLG,_AND
        ''      If not interactive then CRLF (no other response)
        word    SKIPZ,CRLF
        ''      do not execute if still defining
eol02   word    w+defining,CHKFLG,_ZEQ,_AND
        ''      wait until CR to execute compiled codes
        word    _UNTIL+(.L0-WORDLP)/2
.L0
execs   ''      EXECUTE CODE from user input (append an EXIT first)
        word    w+EXIT,COMPW
        ''      execute wordcodes from beginning
execinp word    ATHERE,ACALL
        ''      execute accept vector if 0<>
''        word    rg+uaccept,WFETCH,QDUP,_IF+02,ACALL,LINELP+ex
        word    rg+linenum,WFETCH,SKIPNZ,OK,LINELP+ex


'-------------------------------------------------------------

TRYNUM  ''      Attempt to process this word as a number but check for special literals first (^ ' etc)
        word    rg+wordbuf,NUMBER,_IF+06
        ''      is it a number? ( value digits )
compnum	''	COMPILE THE NUMBER
	word	DNUMQ,_IF+02,SWAP,LITCOMP
	word	LITCOMP
	word	chkeol+ex

        ''      Unknown word or number - try converting case first time
UNKNOWN word    rg+fflags+1,CFETCH,_4,_AND,_ZEQ
        word    _IF+06,_4,rg+fflags+1,CPLUSST
        word    rg+wordbuf,TOUPPER,trm4+ex
        ''      UNKNOWN - try unum vector if set
        word    rg+unum,WFETCH,QDUP,_IF+02,ACALL,chkeol+ex
'
' Failed all searches and conversions!!!!
'
        ''      interactive or in the middle of a definition?
        word    w+defining,rg+fflags,CFETCH,_AND,_IF+(HUH-nfdef)/2
        ''      Display position in line of error
nfdef   word    PRTSTR
        byte    9,9,"  error in ",0
	''	display latest definition
        word    ATNAMES,CFETCHINC,w+$1F,_AND,CTYPE,PRTSTR
        byte    "  at ",0
        ''      Spit out offending word
        word    rg+wordbuf,PRINTSTR,SPACE
        ''      discard but echo remainder of line
.L0     word    WKEY,DUP,_13,_NEQ,_IF+02,EMIT,.L0+ex,DROP
	'word	DEBUG

        ''      count errors and force a new line to display error
ERROR   word    rg+errors,WINC	'',CR,w+$10A,EMIT
ERRSTR  word    PRTSTR
        byte    " *error* ",7,$0D,$0A,$0B,0
        '
        ''      force a new line to prevent overwrite then return to console
ERROUT	word    w+$10A,EMIT,DISCARD,INITSP,_END,CONSOLE+ex

'pri ?ERROR ( cond n -- )		IF .AS"  ERROR# #~# " R> DROP CONSOLE EXIT THEN DROP ;
QERROR	word	SWAP,_IF+09,PRTSTR
	byte	"   ERROR - ",0
	word	PRINTSTR,ERROUT+ex
	word	DROP,EXIT

        ' as-you-go error prompt in interactive mode
HUH     word    PRTSTR
        byte    " ??? ",0
        word    WORDLP+ex





' KEY! ( ch -- ) Force a character as the next KEY read
PUTKEY
        word    rg+keychar,STOREX+ex

' KEY ( -- ch ) if ch is zero then no key was read
KEY     word    rg+keychar,CFETCH,QDUP,_IF+06      		' read a "key" that was forced with KEY!
        word    rg+keychar,FETCH,_SHR8,rg+keychar,STORE,CHKKEY+ex ' up to 4 keys may be forced
        word    rg+ukey,WFETCH,_IF+06,rg+ukey,WFETCH,ACALL
	word 	DUP,IFEXIT,DOPOLL+ex
CONKEY  word    READRX
DOKEY   word    DUP,_IF+07 'DOPOLL
        word    BITS8,DUP,_ZEQ,ZEXIT                    	' return as if non-zero
        word    w+$0100,PLUS,EXIT                            	' otherwise add $100 to a null
       '
DOPOLL  word    rg+keypoll,QJMP                         	' execute background polling while waiting for input
        word    EXIT

' keep a track of the position of the this key on the input line (useful for assembler etc)
CHKKEY  word    rg+keycol,CINC,DUP,_13,_EQ,ZEXIT,rg+keycol,CLRC,EXIT

                                        ' background polling while waiting for a key

' WKEY ( -- ch ) wait for a key and return with character
WKEY    word    KEY,QDUP,_UNTIL+03,BITS8,EXIT




_ECHO   word    w+echo,rg+fflags,ROT,BITST,EXIT

' TAQOZ marks the start of a block of source code to be compiled in block mode
'
_TAQOZ
        word    PRTVER
        ''      disable background keypoll during load & reset error count
        word    rg+keypoll,CLRW,rg+errors,CLRW
        ''      remember code position for reporting
        word    ATHERE,rg+fromhere,STORE
        ''      reset line# to 1 to active
        word    _1,rg+linenum,WSTORE,_0,_ECHO
        ''      backup dictionary pointer
''        word    ATNAMES,rg+oldnames,STORE
        ''      time the load
        word    _GETCNT,rg+spincnt,STOREX+ex

' end of block load mode  TAQOZ <source> END
'
_END    word    _TRUE,_ECHO
        ''      read linenum and clear to exit line mode
        word    rg+linenum,WFETCH,rg+linenum,CLRW
        word    CRLF,PRTDEC,PRTSTR
        byte    " lines and ",0
        word    ATHERE,rg+fromhere,FETCH,MINUS,PRTDECL,PRTSTR
        byte    " bytes compiled,  with ",0
        word    rg+errors,WFETCH,PRTDEC,PRTSTR
        byte    " errors in ",0
        ''      report compile time
        word    _GETCNT,rg+spincnt,FETCH,MINUS,CLKHZ,w+1000,UDIVIDE,UDIVIDE,PRTDECL,PRTSTR
        byte    "ms ",0
        word    _2,CLRFLG+ex


'-------------------------------------------------------------



{ *** COMMENTING *** }

''      \       ( -- )
''      Ignore following text till the end of line.
''      IMMED
COMMENT
        word    rg+delim+1,CFETCH,_13,_NEQ,ZEXIT                        ' ignore is this is an empty line
.L0     word    WKEY,DUP,QEMIT,_13,_EQ,_UNTIL+06                        ' terminate comment on a CR
        word    _13,rg+keychar,STOREX+ex                                ' force a CR back into the key stream on exit

PAREN	word    WKEY,DUP,QEMIT,w+")",_EQ,_UNTIL+06,EXIT

IFDEF	word    NFATICK,_ZEQ,ZEXIT,BRACE+ex

IFNDEF	word    NFATICK,ZEXIT
        ''''
' Block comments - allow nested  operation
        ''''
BRACE
        word    _1                                              ' allow nesting by counting braces
.LP     word    WKEY                                            ' keep reading each char until we have a matching closing brace
        word    DUP,w+"{",_EQ,_IF+03,DROP,INC,.LP+ex    ' add up opening braces
        word    w+"}",_EQ,SKIPZ,DEC                             ' count down closing braces
        word    DUP,_ZEQ,_UNTIL+15,DROPEX+ex



' 06,F,O,R,G,E,T,CODEL,CODEH

FORGET  word    NFATICK,GRAB,QDUP,_IF+17
        word    DUP,DUPCFT,PLUS,_3,PLUS,rg+names,STORE
        word    DUPCFT,PLUS,INC,WFETCH,DUP,rg+here,STORE
        word    w+EXIT,SWAP,WSTOREX+ex
NOTFOUND
        word    PRTSTR
        byte    " not found ",0
        word    EXIT

' >W
TOW     word    w+16,BITS,EXIT
' L>W
L2W     word    DUP,TOW,SWAP,_SHR16,EXIT
' W>B ( word bytel byteh )
W2B     word    DUP,BITS8,SWAP,_SHR8,BITS8,EXIT

B2L     word    B2W,PUSHL,B2W,LPOP
W2L     word    _SHL8
B2W     word    _SHL8,ORX+ex


' CTYPE ( str cnt -- )
CTYPE   word    ADO,IX,CFETCH,AEMIT,LOOP,EXIT
' CTYPE   word    ADO,IX,CFETCH,TOCHAR,EMIT,LOOP,EXIT

{
----------------------------------------------------------------
  Parallax P2  .:.:--TAQOZ--:.:.  V1.2 'CHIP'        190104-2300
----------------------------------------------------------------
}
' .VER
PRTVER
        word    PRTSTR
                '12345678901234567890123456789012345678901234567890123456789011'
''        byte    "  Parallax P2  .:.:--TAQOZ--:.:.  V",0
        byte    "  Parallax P2  *TAQOZ* Extensible Firmware  V",0
        word    _WORD,@taqoz_version,FETCH
	word	PRTAST
        byte    "#~#.# '",0
	word	_WORD,@taqoz_name,_4,CTYPE,w+"'",EMIT
	word	SPACE,PRTCLK,SPACE
        word	_WORD,@taqoz_time,FETCH,PRTAST
	byte	"6|-4|",0
	word	CRLF+ex


{
00.2488: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
DICTIONARY
00.D000: 03 44 55 50 6B 00 04 32 44 55 50 6D 00 04 4F 56    .DUPk..2DUPm..OV
00.D010: 45 52 6E 00 04 44 52 4F 50 61 00 05 32 44 52 4F    ERn..DROPa..2DRO
00.D020: 50 60 00 04 53 57 41 50 75 00 05 32 53 57 41 50    P..SWAPu..2SWAP
00.D030: 50 0D 03 52 4F 54 7A 00 04 2D 52 4F 54 79 00 03    P..ROTz..-ROTy..
}
_WORDS	word	rg+delim+1,CFETCH,w+$0D,_NEQ,_IF+01,dwords+ex
'		             track maximum line width & clear words & word count
WORDS   word    rg+spincnt,CLRL
MWORDS
	word	ATNAMES,DUP,PRTADR
''		new line?
.l0     word    rg+spincnt+1,CFETCH,w+90,GT,_IF+03,CRLF,rg+spincnt+1,CLRC
	word	rg+spincnt,CFETCH,_IF+05,rg+spincnt,DUP,CDEC,CFETCH,_IF+19
        word    DUPCFT,_IF+17
        word    rg+spincnt+2,WINC
        ''       track width '
        word    DUPCFT,w+cntm,_AND,INC,rg+spincnt+1,CPLUSST
        word    DUP,CFETCHINC,w+cntm,_AND,CTYPE,SPACE,NFACPA,INC2,.l0+ex

        word    DROP,rg+spincnt+2,WFETCH,SPACE,PRTDEC+ex

QWORDS	word	w+80,rg+spincnt,STORE,MWORDS+ex
{
PRT3S   word    LHASH,HASH,HASH,HASH,w+".",HOLD,HASHS,RHASH,PSTR+ex

PRTF    word    CLKHZ,_WORD,10000,UDIVIDE,DUP,w+100,UMOD,_IF+02
        word    PRT3S,.L0+ex
        word    w+100,UDIVIDE,PRINT
.L0     word    PRTSTR
        byte    "MHz",0
        word    EXIT
}



_datsav	long	0
_datorg long    datram
_datptr long    datram

ORGPTR	word	_WORD,_datptr,EXIT
ATORG	word	_WORD,_datorg,EXIT
' orglen'
DATLEN	word	ATDAT,ATORG,FETCH,MINUS,EXIT
' org@ '
ATDAT   word    ORGPTR,FETCHX+ex
' !org '
INITORG	word	_WORD,_datsav,FETCH
' org '
DATORG	word	ATDAT,_WORD,_datsav,STORE		' backup org '
  	word    DUP,ATORG,STORE,ORGPTR,STOREX+ex

' pub res ( bytes -- )                  _datptr +! ;
dres    word    dres1,COMMENT+ex
dres1	word	GRAB,_WORD,_datptr,PLUSST,EXIT

' pre words                             [C] GRAB 2* [C] BYTES ;
' pre LONGS                             [C] GRAB 4* [C] BYTES ;
' pre BYTES ( bytes <name> -- )         [C] GRAB DATPTR SWAP res [C] DATCON ;
dlongs  word    GRAB,_SHL1
dwords  word    GRAB,_SHL1
dbytes  word    GRAB,ATDAT,SWAP,dres1,_DATCON+ex
dbyte   word    _1,dbytes+ex
dword   word    _2,dbytes+ex
dlong   word    _4,dbytes+ex

''''''''''''''''''''''''''''''''''''''''''''''''''''
'		 SERIAL FLASH
''''''''''''''''''''''''''''''''''''''''''''''''''''
' TO DO - remove hard references to SPI Flash pins'
' sck mosi miso ss'

' ADDRESS OF TAQOZ BACKUP/RESTORE IN FLASH'
BRORG	word	CONL
	long	flashpart
SFSIG	word	CONL
	long	flashsig


	'' WRITE ENABLE
SFWE    word    SFBSY,w+6,SFCMD
SFCMD
_SFPINS	word	_LONG
_sfck	byte	spi_ck
_sfdi	byte	spi_di
_sfdo	byte	spi_do
_sfcs	byte	spi_cs
	word	SPIPINS,SPIWR8,EXIT

        '' Set which pins are used by Serial Flash ( &cs.so.si.ck -- )
SFPINS  word    _WORD,_sfck,STOREX+ex


SFWD    word    _4,SFCMD+ex
'	'
SFSTAT  word    _5
SFRD1   word    SFCMD,_0,SPIRD
SFEX	word	SPICE,EXIT



        '' ( Read serial Flash serial number )
SFSID   word    w+$4B,SFCMD
SFRDD	word	_0,SPIRDL,SPIRDL
SFRDL	word	_0,SPIRDL,SFEX+ex
        '' ( Read serial Flash Jedec ID )
SFJID   word    w+$9F,SFCMD,SFRDL+ex
PRTSF	word	SFJID,PRTL,SPACE,SFSID,PRTL,SCORE,PRTL+ex

        ''( addr -- )
SFER4   word    w+$20
SFER    word    SFWE,SPIWM,SPICE
SFBSY   word    SFSTAT,_ZEQ,_UNTIL+03,EXIT

        ''( addr -- )
SFER32  word    w+$52,SFER+ex
        '' SFER64K ( addr -- )
SFER64  word    w+$D8,SFER+ex

SFERALL word    w+$C7,SFWE,SFEX+ex

        '' SFWRPAGE ( src dst -- )
SFWRPAGE word   w+$02,SFWE,SPIWM,w+256,SPITX,SFEX+ex
	'' SFERPAGE ( page pages -- )
SFERPAGE
	word	ADO,IX,_16,_SHL,SFER64,w+200,ms,LOOP,EXIT

'' pub BACKUP			$0F.0000 SFER64 200 ms " TAQO" @ 4 ! 0 $0F.0000 $1.0000 SFWRS ;



        '' BACKUP the first 64K of memory into flash
BACKUP	word	SFJID,DUP,INC,_AND,ZEXIT	'EXIT IF BLANK ID'
  	word    W+flashpage,_2,SFERPAGE
	word	_WORD,brstr,FETCH,STORE
	word	_0,BRORG,w+127,KB
        ''SFWRS ( hubsrc sfdst cnt -- )
SFWRS   word    ROT,SWAP,ADO,IX,OVER,SFWRPAGE,SPINNER,w+256,PLUS,w+256,PLOOP,DROPEX+ex

	'' SFRDW ( -- data16 )
SFRDW   word    _0,SPIRD,_0,SPIRD,_SHL8,ORX+ex

        '' SFR ( addr -- )
SFRD    word    _3,SFCMD,SPIWM,EXIT

brstr	byte	"TAQO"

	'' RESTORE TAQOZ from FLASH by copying to $2.0000 first'
RESTORE	word	SFSIG,SFFETCH,_WORD,brstr,FETCH,_EQ,ZEXIT
''	word	BRORG,_WORD,$1000,PLUS,_WORD,$1000,_WORD,$F000,SFRDS,EXIT
	word	BRORG,_0,w+128,KB
	'' ( sfadr dst cnt -- ) '' read block from SF to RAM
SFRDS	word    ROT,SFRD,SPIRX,SFEX+ex
SPIX    word    SPICE,EXIT

	'' SFC@
SFCFETCH
        word    SFRD,_0,SPIRD,SFEX+ex
        ''pub SFW@
SFWFETCH
        word    SFRD,SFRDW,SFEX+ex

        ''pub SF@ ( addr -- long )
SFFETCH word    SFRD,SFRDW,SFRDW,_SHL16,_OR,SFEX+ex

        '' SF  Select Serial Flash as memory for DUMP words
SF      word    SETDMP,SFCFETCH,SFWFETCH,SFFETCH

	' sdcard
codeorg

	orgh ramdict
'************************************************************************************
'************************************** DICTIONARY **********************************
'************************************************************************************
dat

{ *** DICTIONARY *** }
        orgh

romdict

' The count field is left blank but filled in at cold boot so that these do not need to be calculated when defining
'
        ''      CNT,NAME,ATR,addr16
        byte 3, 	"DUP"
        word DUP
        byte 4, 	"OVER"
        word OVER
	byte 3, 	"3RD"
        word THIRD
        byte 3, 	"4TH"
        word FOURTH

	byte 5, 	"OVER+"
        word OVERPLUS

'
        byte 4, 	"SWAP"
        word SWAP
        byte 3, 	"ROT"
        word ROT
        byte 4, 	"-ROT"
        word ROT2
        byte 4, 	"DROP"
        word DROP

        byte 5, 	"2DROP"
        word DROP2
        byte 5, 	"3DROP"
        word DROP3
        byte 3, 	"NIP"
        word NIP
        byte 5, 	"2SWAP"
        word DSWAP
        byte 4, 	"2DUP"
        word DUP2
        byte 4, 	"?DUP"
        word QDUP

	byte 3,		"OP2"
	word OP2
' BITWISE LOGIC
        byte 3, 	"AND"
        word _AND
        byte 4, 	"ANDN"
        word _ANDN
        byte 2, 	"OR"
        word _OR
        byte 3, 	"XOR"
        word _XOR

''        byte 5, 	"ZEROX"
''        word _ZEROX

' SHIFT'
        byte 3, 	"ROL"
        word _ROL
        byte 3, 	"ROR"
        word _ROR

	byte 4, 	"ROR?"
        word _RORQ
	byte 4, 	"WRCH"
        word WRCH


        byte 2, 	">>"
        word _SHR
        byte 2, 	"<<"
        word _SHL
        byte 3, 	"SAR"
        word _SAR
        byte 2, 	"2/"
        word _SHR1
        byte 2, 	"2*"
        word _SHL1
        byte 2, 	"4/"
        word _SHR2
        byte 2, 	"4*"
        word _SHL2

	byte 4, 	"16<<"
        word _SHL16
        byte 3, 	"8<<"
        word _SHL8
	byte 3, 	"9<<"
        word _SHL9
        byte 4, 	"16>>"
        word _SHR16
        byte 3, 	"8>>"
        word _SHR8
        byte 3, 	"9>>"
        word _SHR9

        byte 3, 	"REV"
        word _REV
        byte 2, 	"|<"
        word MASK
        byte 2, 	">|"
        word ENCODE

	byte 2, 	"1&"
        word _AND1
        byte 2, 	">N"
        word BITS4
        byte 2, 	">B"
        word BITS8
        byte 2, 	">9"
        word BITS9
        byte 4, 	"BITS"
        word BITS


        byte 3, 	"NOT"
        word _NOT

' COMPARISON
        byte 1, 	"="
        word _EQ
        byte 2, 	"<>"
        word _NEQ

        byte 2, 	"0="
        word _ZEQ
        byte 3, 	"0<>"
        word _ZNE
        byte 2, 	"0<"
        word _ZLT
        byte 1, 	"<"
        word LT
        byte 2, 	"U<"
        word _ULT
        byte 1, 	">"
        word GT
        byte 2, 	"U>"
        word UGT
        byte 2, 	"<="
        word LTEQ
        byte 2, 	"=>"
        word EQGT
        byte 6, 	"WITHIN"
        word WITHIN

        byte 5, 	"DUPC@"
        word DUPCFT

        byte 2, 	"C@"
        word CFETCH
        byte 2, 	"W@"
        word WFETCH
        byte 1, 	"@"
        word FETCH
        byte 3, 	"C+!"
        word CPLUSST
        byte 2, 	"C!"
        word CSTORE
        byte 4, 	"C@++"
        word CFETCHINC
        byte 3, 	"W+!"
        word WPLUSST
        byte 2, 	"W!"
        word WSTORE
        byte 2, 	"+!"
        word PLUSST
        byte 1, 	"!"
        word STORE

	byte 2,		"D@"
	word FETCH2
	byte 2,		"D!"
	word STORE2

        byte 4, 	"BIT!"
        word BITST
        byte 3, 	"SET"
        word SET
        byte 3, 	"CLR"
        word CLR
        byte 4, 	"SET?"
        word BITQ



' MATHS
        byte 2, 	"1+"
        word INC
        byte 2, 	"1-"
        word DEC
        byte 2, 	"2+"
        word INC2
        byte 2, 	"2-"
        word DEC2
        byte 2, 	"4+"
        word INC4
        byte 1, 	"+"
        word PLUS
        byte 1, 	"-"
        word MINUS
	byte 3,		"b++"
	word bINC
        byte 3, 	"UM*"
        word UMMUL
        byte 1, 	"*"
        word MULTIPLY
        byte 2, 	"W*"
        word MUL16

	byte 3,		"DM*"
	word DMMUL


        byte 1, 	"/"
        word DIVIDE
        byte 2, 	"U/"
        word UDIVIDE
        byte 3, 	"U//"
        word UDIVMOD
        byte 2, 	"//"
        word UMOD
        byte 2, 	"*/"
        word MULDIV
        byte 4, 	"UM//"
        word UMDIVMOD64

        byte 3, 	"C++"
        word CINC
        byte 3, 	"C--"
        word CDEC
        byte 3, 	"W++"
        word WINC
        byte 3, 	"W--"
        word WDEC
        byte 2, 	"++"
        word LINC
        byte 2, 	"--"
        word LDEC

        byte 3, 	"RND"
        word _RND
        byte 6, 	"GETRND"
        word _GETRND
        byte 4, 	"SQRT"
        word _SQRT
	byte 7, 	"SETDACS"
        word _SETDACS

        byte 1, 	"~"
        word CLRL
        byte 2, 	"~~"
        word SETL
        byte 2, 	"W~"
        word CLRW
        byte 3, 	"W~~"
        word SETW
        byte 2, 	"C~"
        word CLRC
        byte 3, 	"C~~"
        word SETC

        byte 3, 	"L>S"
        word L2S
        byte 2, 	">W"
        word TOW
        byte 3, 	"L>W"
        word L2W
        byte 3, 	"W>B"
        word W2B
        byte 3, 	"W>L"
        word W2L
        byte 3, 	"B>W"
        word B2W
        byte 3, 	"B>L"
        word B2L



        byte 4, 	"MINS"
        word _MINS
        byte 4, 	"MAXS"
        word _MAXS
        byte 3, 	"MIN"
        word _MIN
        byte 3, 	"MAX"
        word _MAX

        byte 3, 	"ABS"
        word _ABS

        byte 7, 	"-NEGATE"
        word MNEGATE
        byte 7, 	"?NEGATE"
        word QNEGATE
        byte 6, 	"NEGATE"
        word NEGATE


' CONSTANTS '
        byte 2, 	"ON"
        word MINUS1
        byte 4, 	"TRUE"
        word MINUS1
        byte 2, 	"-1"
        word MINUS1

        byte 5, 	"FALSE"
        word _0
        byte 3, 	"OFF"
        word _0



' STRUCTURES
        byte 4+im,      "GOTO"
        word GOTO
        byte 2+im,      "IF"
        word _IF_
        byte 4+im,      "ELSE"
        word _ELSE_
        byte 4+im,      "THEN"
        word _THEN_
        'byte 5,        "ENDIF"         +im
        'word                   _THEN_
        byte 5+im,      "BEGIN"
        word _BEGIN_
        byte 5+im,      "UNTIL"
        word _UNTIL_
        byte 5+im,      "AGAIN"
        word _AGAIN_
        byte 5+im,      "WHILE"
        word _IF_
        byte 6+im,      "REPEAT"
        word _REPEAT_

        byte 6,         "SWITCH"
        word _SWITCH
        byte 5,         "CASE@"
        word SWFETCH

''	byte 5,         "CASE="
''        word ISEQ
''
        byte 6+im,      "<CASE>"
        word INCASE
        byte 5+im,      "BREAK"
        word ISEND
        byte 4+im,      "CASE"
        word _CASE

' LOOPS'
        byte 3, 	"ADO"
        word ADO
        byte 2, 	"DO"
        word DO
        byte 4, 	"LOOP"
        word LOOP
        byte 5, 	"+LOOP"
        word PLOOP
        byte 3, 	"FOR"
        word FOR
        byte 4, 	"NEXT"
        word forNEXT
        byte 5, 	"?NEXT"
        word QNEXT
        byte 1, 	"I"
        word IX
        byte 1, 	"J"
        word J
        byte 5, 	"LEAVE"
        word LEAVE
        byte 3, 	"IC@"
        word ICFETCH
        byte 2, 	"I+"
        word IPLUS
        byte 6, 	"BOUNDS"
        word BOUNDS


' -------------I/O---------------

        byte 1, 	"H"
        word H
        byte 1, 	"L"
        word L
        byte 1, 	"T"
        word _T
        byte 1, 	"F"
        word F
        byte 1, 	"R"
        word R
        byte 4, 	"HIGH"
        word HIGH
        byte 3, 	"LOW"
        word LOW
        byte 5, 	"FLOAT"
        word _FLOAT
	byte 6,		"MSBOUT"
	word MSBOUT
	byte 6,		"MSBOUT"
	word LSBOUT

        byte 4, 	"PIN@"
        word PINTEST


' SMARTPIN INSTRUCTIONS
        byte 5, 	"WRPIN"
        word _WRPIN
        byte 5, 	"WXPIN"
        word _WXPIN
        byte 5, 	"WYPIN"
        word _WYPIN

        byte 5, 	"RDPIN"
        word _RDPIN
        byte 5, 	"RQPIN"
        word _RQPIN
        byte 5, 	"AKPIN"
        word _AKPIN
	byte 6, 	"RDPINC"
        word _RDPINC

        byte 7, 	"WAITPIN"
        word WAITPIN

        byte 5, 	"WRACK"
        word WRACK



        byte 3, 	"PIN"
        word _PIN
        byte 4, 	"@PIN"
        word _ATPIN

        byte 5, 	"WAITX"
        word DELTA
        byte 7, 	"WAITCNT"
        word WAITCNTS

{
	byte 6,		"SETSE1"
	word		_SETSE1
	byte 6,		"SETSE2"
	word		_SETSE2
	byte 6,		"SETSE3"
	word		_SETSE3
	byte 6,		"SETSE4"
	word		_SETSE4

	byte 7,		"WAITSE1"
	word		_WAITSE1
	byte 7,		"WAITSE2"
	word		_WAITSE2
	byte 7,		"WAITSE3"
	word		_WAITSE3
	byte 7,		"WAITSE4"
	word		_WAITSE4
}


        byte 6, 	"REBOOT"
        word REBOOT
        byte 5, 	"RESET"
        word RESET
        byte 5, 	"0EXIT"
        word ZEXIT
        byte 4+im,  	"EXIT"
        word EXITS
''      byte 6, 	"SKIPNZ"
''      word SKIPNZ

        byte 3, 	"NOP"
        word _NOP
        byte 4, 	"CALL"
        word ACALL
        byte 4, 	"JUMP"
        word AJMP


        byte 2, 	">R"
        word PUSHR
        byte 2, 	"R>"
        word RPOP
        byte 2, 	">L"
        word PUSHL
        byte 2, 	"L>"
        word LPOP
        byte 3, 	"!SP"
        word INITSP
        byte 5, 	"DEPTH"
        word _DEPTH

        byte 4, 	"COG@"
        word COGFETCH
        byte 4, 	"COG!"
        word COGSTORE
        byte 4, 	"LUT@"
        word LUTFETCH
        byte 4, 	"LUT!"
        word LUTSTORE

        byte 5, 	"COGID"
        word _COGID
        byte 7, 	"COGINIT"
        word _COGINIT
        byte 7, 	"COGSTOP"
        word _COGSTOP

	byte 6, 	"NEWCOG"
        word NEWCOG

        byte 6, 	"COGATN"
        word _COGATN
        byte 7, 	"POLLATN"
        word _POLLATN
        byte 6, 	"SETEDG"
        word _SETEDG
        byte 7, 	"POLLEDG"
        word _POLLEDG




        byte 3, 	"KEY"
        word KEY
	byte 4, 	"WKEY"
        word WKEY
        byte 4, 	"KEY!"
        word PUTKEY

''      byte 7, 	"keypoll"
''      word rg+keypoll

        byte 3, 	"CON"
        word _CON
        byte 4, 	"NONE"
        word NONE
        byte 3, 	"COM"
        word _COM


''      byte 7, 	"DISCARD"
''      word DISCARD

        byte 6, 	"CONKEY"
        word CONKEY
        byte 7, 	"CONEMIT"
        word CONEMIT
	byte 6, 	"SEROUT"
        word SEROUT

	byte 5, 	".EMIT"
        word AEMIT
        byte 4, 	"EMIT"
        word EMIT
        byte 5, 	"EMITS"
        word EMITS

        byte 4, 	"CRLF"
        word CRLF
        byte 2, 	"CR"
        word CR
        byte 3, 	"CLS"
        word CLS
{
        byte 3, 	"DOT"
        word DOT
}
        byte 5, 	"SPACE"
        word SPACE
        byte 6, 	"SPACES"
        word SPACES

' DUMP MEMORY
        byte 3, 	"RAM"
        word RAM
        byte 5, 	"DUMP:"
        word SETDMP
        byte 4, 	"DUMP"
        word DUMP
        byte 5, 	"DUMPW"
        word DUMPW
        byte 5, 	"DUMPL"
        word DUMPL
        byte 5, 	"DUMPA"
        word DUMPA
        byte 6, 	"DUMPAW"
        word DUMPAW
        byte 2, 	"QD"
        word QD
	byte 2, 	"QW"
        word QW

	byte 6,		"?ERROR"
	word QERROR
	byte 7,		"CONSOLE"
	word CONSOLE
        byte 5, 	"DEBUG"
        word DEBUG
        byte 4, 	"lsio"
        word lsio

        byte 3, 	"COG"
        word _COG
        byte 3, 	"LUT"
        word _LUT

        byte 2, 	"KB"
        word KB
        byte 2, 	"MB"
        word MB
        byte 1, 	"M"
        word M


' PRINTING

        byte 1, 	"."
        word PRT
        byte 5, 	"PRINT"
        word PRT

        byte 3, 	".AS"
        word PRTAS
        byte 4+im,      ".AS",$22
        word PRTASR

        byte 5, 	".DECL"
        word PRTDECL
        byte 5, 	".DEC4"
        word PRTDEC4
        byte 5, 	".DEC2"
        word PRTDEC2

''      byte c, 	"@PAD"
''      word ATPAD
        byte 4, 	"HOLD"
        word HOLD
''      byte 5, 	">CHAR"
''      word BINASC
        byte 2, 	"#>"
        word RHASH
        byte 2, 	"<#"
        word LHASH
        byte 1, 	"#"
        word HASH
        byte 2, 	"#S"
        word HASHS
        byte 3, 	"<D>"
        word DNUM

        byte 2, 	"U."
        word UPRT
        byte 4, 	".DEC"
        word PRTDEC
        byte 4, 	".BIN"
        word PRTBIN

	byte 2, 	".H"
        word PRTHEX
        byte 2, 	".B"
        word PRTB
        byte 5, 	".BYTE"
        word PRTBYTE
        byte 2, 	".W"
        word PRTW
        byte 5, 	".WORD"
        word PRTWORD
        byte 2, 	".L"
        word PRTL
        byte 5, 	".LONG"
        word PRTLONG

        byte 5, 	".ADDR"
        word PRTADR


        byte 6, 	"PRINT$"
        word PRINTSTR
        byte 4, 	"LEN$"
        word STRLEN

	byte 6,		"UPPER$"
	word TOUPPER

        byte 1+im,      $22
        word _STRING_
        byte 2+im,      $2E,$22
        word _PSTR_          ' ."
	byte 6+im,      "PRINT",$22
        word _PSTR_
        byte 5, 	"CTYPE"
        word CTYPE

	byte 6,		"NUMBER"
	word NUMBER


        byte 5, 	"?EXIT"
        word IFEXIT


' MEMORY BLOCKS
''        byte 5, 	"DATA?"
''        word DATAQ
        byte 5, 	"ERASE"
        word ERASE
        byte 4, 	"FILL"
        word CFILL
        byte 5, 	"CMOVE"
        word CMOVE
        byte 6, 	"<CMOVE"
        word RCMOVE
	byte 5, 	"LMOVE"
        word LMOVE

' TIMING
        byte 1, 	"s"
        word secs
        byte 2, 	"ms"
        word ms
        byte 2, 	"us"
        word us

' LAP TIMING
        byte 4, 	"CNT@"
        word _GETCNT
        byte 3, 	"LAP"
        word LAP
        byte 4, 	"LAP@"
        word LAPFETCH
        byte 4, 	".LAP"
        word PRTLAP
	byte 4, 	".CLK"
        word PRTCLK
        byte 3, 	".ms"
        word PRTMS


' RADIX
        byte 3, 	"HEX"
        word HEX
        byte 3, 	"DEC"
        word DECIMAL
        byte 3, 	"BIN"
        word BIN

        byte 2, 	".S"
        word PRTSTK


' DICTIONARY
        byte 1, 	"W"
        word QWORDS
        byte 6, 	"WWORDS"
        word WORDS
        byte 6, 	"@WORDS"
        word ATNAMES
        byte 4, 	"GET$"
        word _GETWORD
        byte 6, 	"SEARCH"
        word SEARCH
        byte 3, 	"$>#"
        word NUMBER



' VARIABLES
        byte 5, 	"uemit"
        word rg+uemit
        byte 4, 	"ukey"
        word rg+ukey
        byte 4, 	"char"
        word w+@lastkey
        byte 5, 	"delim"
        word rg+delim
        byte 5, 	"names"
        word rg+names

        byte 4, 	"TASK"
        word TASK
        byte 3, 	"REG"
        word ATREG
        byte 5, 	"@WORD"
        word rg+wordbuf
        byte 4, 	"SPIN"
        word SPINNER


' | compile byte   || compile word   , compile long
'        byte 1+im,      "|"
'        word CCOMP
        byte 2+im,      "||"
        word WCOMP
        byte 1+im,      ","
        word LCOMP
        byte 3+im,      "[W]"
        word COMPW
        byte 3+im,      "[",$22,"]"
        word COMPSTR

        byte 5, 	"NULL$"
        word NULLSTR
        byte 2, 	"$!"
        word STRST
        byte 2, 	"$="
        word STREQ
'	byte 6,		">UPPER"
'	word TOUPPER


' DEFINITIONS
'

	byte 3,		"ASM"
        word _ASM

        byte 6+im,      "FORGET"
        word FORGET
        byte 7+im,      "CREATE$"
        word CREATEWORD
        byte 7+im,      "CREATE:"
        word CREATE
        byte 3+im,      "VAR"
        word _VAR

        byte 3+im,      "pub"
        word PUBDEF
        byte 3+im,      "pri"
        word PRIDEF
        byte 3+im,      "pre"
        word PREDEF
	byte 6+im,      "public"
        word PUBLIC
	byte 7+im,      "private"
        word PRIVATE

{
        byte 6+im,      "module"
        word MODDEF
}
        byte 1+im,      ":"
        word NEWDEF
        byte 1+im,      ";"
        word ENDDEF
        byte 1+im,      "["
        word UNDEF
	byte 1+im,      "]"
        word REDEF
        byte 1+im,      "'"
        word ATICK

''        byte 2+im,      ":="
''        word _CON9
        byte 2+im,      ":="
        word _CONST
        byte 3,         ":=!"
        word CONST
        byte 5,         "ALIGN"
        word _ALIGN

        byte 6+im,      "DATCON"
        word _DATCON

        byte 5,         "ALLOT"
        word ALLOT
	byte 4, 	"HERE"
        word ATHERE
        byte 5, 	"@HERE"
        word rg+here
        byte 6, 	"@CODES"
        word rg+codes


	byte 6,		"orglen"
	word DATLEN
        byte 4, 	"org@"
        word ATDAT
	byte 4, 	"!org"
        word INITORG
        byte 3,         "org"
        word DATORG
        byte 5+im,      "bytes"
        word dbytes
        byte 5+im,      "words"
        word _words
        byte 5+im,      "longs"
        word dlongs
        byte 4+im,      "byte"
        word dbyte
        byte 4+im,      "word"
        word dword
        byte 4+im,      "long"
        word dlong
        byte 3+im,      "res"
        word dres

        byte 3+im,      "[C]"
        word COMPILES
        byte 4+im,	"GRAB"
        word GRAB
	byte 3,		"[G]"
	word GRAB


' FIELDS ( NAME-FIELD  CODE-POINTER CODE-FIELD )
        byte 4+im,      "NFA'"
        word _NFATICK
        byte 3,         "CPA"
        word NFACPA
        byte 3,         "CFA"
        word NFACFA


' COMMENTS
        byte 1+im,      "\"
        word COMMENT
        byte 3+im,      "---"
        word COMMENT
        byte 1+im,      "("
        word PAREN
        byte 1+im,      "{"
        word BRACE
        byte 1+im,      "}"
        word _NOP

' CONDITIONAL COMPILATION ( conditionally ignore as comment )

        byte 6+im,      "IFNDEF"
        word IFNDEF
        byte 5+im,      "IFDEF"
        word IFDEF


''        byte 4, 	"IDLE"
''        word IDLE

''        byte 4, 	".VER"
''        word PRTVER
        byte 5, 	"TAQOZ"
        word _TAQOZ
        byte 4, 	"TERM"
        word TERMINAL
        byte 4+im, 	"AUTO"
        word AUTORUN

        byte 5, 	"SPIRD"
        word SPIRD
        byte 5, 	"SPIRL"
        word SPIRDL
        byte 5, 	"SPIWB"
        word SPIWR8
        byte 5, 	"SPICE"
        word SPICE
        byte 5, 	"SPIWC"
        word SPIWRC
        byte 5, 	"SPIWW"
        word SPIWR16
        byte 5, 	"SPIWM"
        word SPIWM
	byte 5, 	"SPIWL"
        word SPIWRL
        byte 7, 	"SPIPINS"
        word SPIPINS
        byte 5, 	"SPIRX"
        word SPIRX
        byte 6, 	"SPITXE"
        word SPITXE
        byte 5, 	"SPITX"
        word SPITX
	byte 4,		"CLKS"
	word CLKS
{
	byte 5,		"SLOWK"
	word SLOWK
	byte 5,		"FASTK"
	word FASTK
}



        byte 5, 	"CLKIN"
        word CLKIN
        byte 6, 	"CLKOUT"
        word CLKOUT
        byte 5, 	"CLOCK"
        word CLOCK

{
       byte 5, 	"WSLED"
        word WSLED
}
        byte 4, 	"WAIT"
        word WAIT

        byte 6, 	"CLKDIV"
        word CLKDIV
        byte 6, 	"RCSLOW"
        word RCSLOW


        byte 6, 	"HUBSET"
        word _HUBSET
        byte 2, 	"WP"
        word WP
        byte 2, 	"WE"
        word WE


        byte 5, 	"CLKHZ"
        word CLKHZ

        byte 5, 	"ERROR"
        word ERROR

        byte 6, 	"SFPINS"
        word SFPINS
        byte 3, 	"SF?"
        word SFSTAT
        byte 4, 	"SFWE"
        word SFWE
        byte 5, 	"SFCMD"		' SFINS '
        word SFCMD
        byte 4, 	"SFWD"
        word SFWD
        byte 5, 	"SFSID"
        word SFSID
        byte 5, 	"SFJID"
        word SFJID
        byte 5, 	"SFER4"
        word SFER4
        byte 6, 	"SFER32"
        word SFER32
        byte 6, 	"SFER64"
        word SFER64
        byte 4, 	"SFER"
        word SFERALL
	byte 5, 	"SFERP"
        word SFERPAGE
        byte 5, 	"SFWRP"
        word SFWRPAGE

        byte 4, 	"SFBU"
        word BACKUP
        byte 4, 	"SFRE"
        word RESTORE
        byte 5, 	"SFRDS"
        word SFRDS

        byte 5, 	"SFWRS"
        word SFWRS
        byte 4, 	"SFC@"
        word SFCFETCH
        byte 4, 	"SFW@"
        word SFWFETCH
        byte 3, 	"SF@"
        word SFFETCH
        byte 2, 	"SF"
        word SF
	byte 3, 	".SF"
        word PRTSF






        byte 3, 	"END"
        word _END
        long    0
enddict
        alignl


{{
+------------------------------------------------------------------------------------------------------------------------------+
|                                                   TERMS OF USE: MIT License                                                  |
+------------------------------------------------------------------------------------------------------------------------------+
|Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    |
|files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    |
|modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software|
|is furnished to do so, subject to the following conditions:                                                                   |
|                                                                                                                              |
|The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.|
|                                                                                                                              |
|THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          |
|WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         |
|COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   |
|ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         |
+------------------------------------------------------------------------------------------------------------------------------+
}}

